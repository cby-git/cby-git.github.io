<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cookie总结</title>
    <link href="/2020/09/01/Cookie%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/01/Cookie%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Cookie的诞生"><a href="#Cookie的诞生" class="headerlink" title="Cookie的诞生"></a>Cookie的诞生</h1><p>​    由于 <code>HTTP 协议</code>是无状态的，服务器无法知道两个请求是否来自同一个浏览器，也不知道用户上一次做了什么，每次请求都是完全相互独立，这严重阻碍了<code>交互式 Web</code> 应用程序的实现。例子：</p><ul><li>购物车：在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 <code>HTTP</code> 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么。</li><li>登录状态：我们常用的“记住密码”功能，在以前如果不是用 <code>Cookie</code> 记住了登录凭据，想要实现该功能将会很复杂。</li></ul><p>正是为了解决这些交互方面存在的痛点，<code>Cookie</code> 应运而生。</p><h1 id="Cookie概述"><a href="#Cookie概述" class="headerlink" title="Cookie概述"></a>Cookie概述</h1><blockquote><p><code>Cookie</code>（ 也叫 <code>Web Cookie</code> 或<code>浏览器 Cookie</code> ）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p></blockquote><p>存储 <code>Cookie</code> 是浏览器提供的功能。<code>Cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 <code>Cookie</code> 文件夹来存放各个域下设置的 <code>Cookie</code>（非内存 <code>Cookie</code>）。</p><p><img src="https://oscimg.oschina.net/oscnet/up-48880bf885b97f85a19713fdf31ab1face7.png" alt="Cookie存放的位置"></p><p>通常，它用于告知服务端两个请求是否来自同一浏览器，或者用来保存一些状态信息，<code>Cookie</code> 使基于无状态的 <code>HTTP</code> 协议记录稳定的状态信息成为了可能。常用的有以下方面：</p><ul><li>对话（<code>session</code>）管理：保存登录、购物车等需要记录的信息。</li><li>简单的缓存：存储一些简单的业务数据，比如购物车等需要记录的信息。</li><li>个性化：保存用户的偏好，比如网页的字体大小、背景色等等。</li><li>追踪：记录和分析用户行为。</li></ul><blockquote><p><code>Cookie</code> 主要是用来存储状态的。</p></blockquote><p><code>Cookie</code> 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段。现在来说，这样做虽然可行，但是并不推荐，因为 <code>Cookie</code> 的设计目标并不是这个，它:</p><ul><li>容量很小（ 4KB ）</li><li>缺乏数据操作接口</li><li>影响性能</li></ul><p>客户端储存应该更多的考虑使用 <code>localStorage</code> 、<code>sesseionStorage</code> 和 <code>IndexedDB</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS DOM操作——节点</title>
    <link href="/2020/08/19/JS%20DOM%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E8%8A%82%E7%82%B9/"/>
    <url>/2020/08/19/JS%20DOM%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h1><p>​    网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。</p><p>​    HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</p><p><img src="./1550970944363.png" alt="1550970944363"></p><p>​    一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><blockquote><ul><li><p>元素节点  nodeType 为  1</p></li><li><p>属性节点  nodeType 为  2</p></li><li><p>文本节点  nodeType  为  3 （文本节点包含文字、空格、换行等）</p><p><strong>实际开发中，节点主要操作的是元素节点</strong></p></li></ul></blockquote><h1 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h1><p>​    利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p><p> <img src="./1550971058781.png" alt="1550971058781"></p><h1 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h1><h2 id="父级节点"><a href="#父级节点" class="headerlink" title="父级节点"></a>父级节点</h2><blockquote><p>node.parentNode</p><ul><li>parentNode 属性可返回某节点的父节点 ，注意<strong>是最近一个父节点</strong></li><li>如果指定的节点没有父节点则返回 null</li></ul></blockquote><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;        &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;erweima&quot;</span>&gt;×&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    <span class="hljs-comment">// 1. 父节点 parentNode</span>    <span class="hljs-keyword">var</span> erweima = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.erweima&#x27;</span>);    <span class="hljs-comment">// var box = document.querySelector(&#x27;.box&#x27;);</span>    <span class="hljs-comment">// 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null</span>    <span class="hljs-built_in">console</span>.log(erweima.parentNode);&lt;/script&gt;</code></pre><h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><p><strong>所有子节点</strong></p><blockquote><p>parentNode.childNodes（标准）返回指定节点的子节点的集合，<strong>该集合为即时更新的集合。</strong></p><p><strong>返回值里面包含了所有的子节点，包括元素节点，文本节点等。</strong></p><p><strong>如果只想要获得里面的元素节点，则需要专门处理。所以一般不提倡使用 childNodes</strong></p></blockquote><p><strong>子元素节点</strong></p><blockquote><p>parentNode.children（非标准）</p><p>这是一个只读属性，返回所有的子元素节点。<strong>只返回子元素节点，其余节点不返回。</strong></p><p>虽然 children 是一个非标准，但是各个浏览器都支持，因此可以放心使用。</p></blockquote><pre><code class="hljs js">&lt;ul&gt;    &lt;li&gt;我是li&lt;/li&gt;    &lt;li&gt;我是li&lt;/li&gt;    &lt;li&gt;我是li&lt;/li&gt;    &lt;li&gt;我是li&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    <span class="hljs-comment">// DOM 提供的方法（API）获取</span>    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);    <span class="hljs-keyword">var</span> lis = ul.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);    <span class="hljs-comment">// 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等</span>    <span class="hljs-built_in">console</span>.log(ul.childNodes);    <span class="hljs-built_in">console</span>.log(ul.childNodes[<span class="hljs-number">0</span>].nodeType);    <span class="hljs-built_in">console</span>.log(ul.childNodes[<span class="hljs-number">1</span>].nodeType);    <span class="hljs-comment">// 2. children 获取所有的子元素节点 也是我们实际开发常用的</span>    <span class="hljs-built_in">console</span>.log(ul.children);&lt;/script&gt;</code></pre><blockquote><p>第一个子节点：parentNode.firstChild</p><p>最后一个子节点：parentNode.lastChild</p><p>第一个子元素节点：parentNode.firstElementChild（返回第一个子元素节点，找不到返回 null）</p><p>最后一个子元素节点：parentNode.lastElementChild（返回最后一个子元素节点，找不到返回 null）</p></blockquote><p>​    实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？</p><p><strong>解决方案：</strong></p><ol><li>如果想要第一个子元素节点，可以使用 parentNode.children[0]</li><li>如果想要获取最后一个子元素节点，可以使用  parentNode.children[parentNode.children.length - 1]</li></ol><pre><code class="hljs js">&lt;ol&gt;    &lt;li&gt;我是li1&lt;/li&gt;    &lt;li&gt;我是li2&lt;/li&gt;    &lt;li&gt;我是li3&lt;/li&gt;    &lt;li&gt;我是li4&lt;/li&gt;    &lt;li&gt;我是li5&lt;/li&gt;&lt;/ol&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> ol = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ol&#x27;</span>);    <span class="hljs-comment">// 1. firstChild 第一个子节点 不管是文本节点还是元素节点</span>    <span class="hljs-built_in">console</span>.log(ol.firstChild);    <span class="hljs-built_in">console</span>.log(ol.lastChild);    <span class="hljs-comment">// 2. firstElementChild 返回第一个子元素节点 ie9才支持</span>    <span class="hljs-built_in">console</span>.log(ol.firstElementChild);    <span class="hljs-built_in">console</span>.log(ol.lastElementChild);    <span class="hljs-comment">// 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素</span>    <span class="hljs-built_in">console</span>.log(ol.children[<span class="hljs-number">0</span>]);    <span class="hljs-built_in">console</span>.log(ol.children[ol.children.length - <span class="hljs-number">1</span>]);&lt;/script&gt;</code></pre><h2 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h2><blockquote><p><strong>下一个兄弟节点</strong></p><p>node.nextSibling    返回当前元素的下一个兄弟节点，找不到返回 null</p><p><strong>上一个兄弟节点</strong></p><p>node.previousSibling  返回当前元素上一个兄弟节点，找不到返回 null</p></blockquote><pre><code class="hljs js">&lt;div&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);    <span class="hljs-comment">// 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等</span>    <span class="hljs-built_in">console</span>.log(div.nextSibling);    <span class="hljs-built_in">console</span>.log(div.previousSibling);    <span class="hljs-comment">// 2. nextElementSibling 得到下一个兄弟元素节点</span>    <span class="hljs-built_in">console</span>.log(div.nextElementSibling);    <span class="hljs-built_in">console</span>.log(div.previousElementSibling);&lt;/script&gt;</code></pre><blockquote><p><strong>下一个兄弟元素节点（有兼容性问题）</strong></p><p>node.nextElementSibling</p><p><strong>上一个兄弟元素节点（有兼容性问题）</strong></p><p>node.nextpreviousElementSibling</p></blockquote><p>注意：nextElementSibling 和 previousElementSibling 都有兼容性问题，IE9 以上才支持。需要我们自己封装一个兼容性函数。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextElementSibling</span>(<span class="hljs-params">element</span>) </span>&#123;   <span class="hljs-keyword">var</span> el = element;   <span class="hljs-keyword">while</span> (el = el.nextSibling) &#123;     <span class="hljs-keyword">if</span> (el.nodeType === <span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">return</span> el;     &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;</code></pre><h1 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h1><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><blockquote><p>document.createElement(‘tagName’)  创建由 tagName 指定的 HTML 元素。因此这些元素原先不存在，是根据我们的需求动态生成的，所有<strong>也称之为动态创建元素节点。</strong></p></blockquote><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><blockquote><p>node.appendChild(child)  将一个节点添加到指定父节点的列表<strong>末尾</strong>。类似于 css 里面的 after 伪元素</p><p>node.insertBefore(child,指定元素)  将一个节点添加到父节点的指定节点<strong>前面</strong>。类似于 css 里面的 before 伪元素</p></blockquote><pre><code class="hljs js">&lt;ul&gt;    &lt;li&gt;<span class="hljs-number">123</span>&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    <span class="hljs-comment">// 1. 创建节点元素节点</span>    <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);    <span class="hljs-comment">// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素</span>    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);    ul.appendChild(li);    <span class="hljs-comment">// 3. 添加节点 node.insertBefore(child, 指定元素);</span>    <span class="hljs-keyword">var</span> lili = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);    ul.insertBefore(lili, ul.children[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素</span>&lt;/script&gt;</code></pre><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。</p><pre><code class="hljs js">&lt;button&gt;删除&lt;/button&gt;&lt;ul&gt;    &lt;li&gt;熊大&lt;/li&gt;    &lt;li&gt;熊二&lt;/li&gt;    &lt;li&gt;光头强&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    <span class="hljs-comment">// 1.获取元素</span>    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);    <span class="hljs-comment">// 2. 删除元素  node.removeChild(child)</span>    <span class="hljs-comment">// ul.removeChild(ul.children[0]);</span>    <span class="hljs-comment">// 3. 点击按钮依次删除里面的孩子</span>    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (ul.children.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">this</span>.disabled = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            ul.removeChild(ul.children[<span class="hljs-number">0</span>]);        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="复制（克隆）节点"><a href="#复制（克隆）节点" class="headerlink" title="复制（克隆）节点"></a>复制（克隆）节点</h2><blockquote><p>node.cloneNode()  返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点</p><p>注意：</p><ol><li>如果括号参数为空或者 <code>flase</code>，则是浅拷贝。即只克隆节点本身，布可隆里面的子节点。</li><li>如果参数为 <code>true</code>。则是深拷贝，会复制节点本身以及里面的所有子节点。</li></ol></blockquote><pre><code class="hljs js">&lt;ul&gt;    &lt;li&gt;<span class="hljs-number">1111</span>&lt;/li&gt;    &lt;li&gt;<span class="hljs-number">2</span>&lt;/li&gt;    &lt;li&gt;<span class="hljs-number">3</span>&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);    <span class="hljs-comment">// 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容</span>    <span class="hljs-comment">// 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容</span>    <span class="hljs-keyword">var</span> lili = ul.children[<span class="hljs-number">0</span>].cloneNode(<span class="hljs-literal">true</span>);    ul.appendChild(lili);&lt;/script&gt;</code></pre><h1 id="创建元素的三种方式"><a href="#创建元素的三种方式" class="headerlink" title="创建元素的三种方式"></a>创建元素的三种方式</h1><blockquote><ul><li>document.write()</li><li>element.innerHTML()</li><li>document.createElement()</li></ul></blockquote><p><strong>区别：</strong></p><ol><li><p>document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它<strong>会导致页面全部重绘</strong></p></li><li><p>innerHTML 将内容写入某个 DOM 节点，不会导致页面重绘</p></li><li><p>innerHTML 创建多个元素效率更高（不要拼接字符串，采用数组的形式拼接），结构稍微复杂</p></li><li><p>createElement()  创建多个元素效率稍微低一些，但是结构清晰</p><p><strong>总结：不同浏览器下，innerHTML 效率要比 createElement 高</strong></p></li></ol><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-comment">// 三种创建元素方式区别 </span>    <span class="hljs-comment">// 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘</span>     <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>);     btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;         <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;&lt;div&gt;123&lt;/div&gt;&#x27;</span>);     &#125;    <span class="hljs-comment">// 2. innerHTML 创建元素</span>    <span class="hljs-keyword">var</span> inner = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.inner&#x27;</span>);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;         inner.innerHTML += <span class="hljs-string">&#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;</span>     &#125;    <span class="hljs-keyword">var</span> arr = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;        arr.push(<span class="hljs-string">&#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;</span>);    &#125;    inner.innerHTML = arr.join(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-comment">// 3. document.createElement() 创建元素</span>    <span class="hljs-keyword">var</span> create = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.create&#x27;</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;        <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);        create.appendChild(a);    &#125;&lt;/script&gt;</code></pre><h2 id="innerTHML和createElement效率对比"><a href="#innerTHML和createElement效率对比" class="headerlink" title="innerTHML和createElement效率对比"></a>innerTHML和createElement效率对比</h2><p><strong>innerHTML字符串拼接方式（效率低）</strong></p><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> d1 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&#x27;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-built_in">document</span>.body.innerHTML += <span class="hljs-string">&#x27;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#x27;</span>;        &#125;        <span class="hljs-keyword">var</span> d2 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-built_in">console</span>.log(d2 - d1);    &#125;    fn();&lt;/script&gt;</code></pre><p><strong>createElement方式（效率一般）</strong></p><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> d1 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);            div.style.width = <span class="hljs-string">&#x27;100px&#x27;</span>;            div.style.height = <span class="hljs-string">&#x27;2px&#x27;</span>;            div.style.border = <span class="hljs-string">&#x27;1px solid red&#x27;</span>;            <span class="hljs-built_in">document</span>.body.appendChild(div);        &#125;        <span class="hljs-keyword">var</span> d2 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-built_in">console</span>.log(d2 - d1);    &#125;    fn();&lt;/script&gt;</code></pre><p><strong>innerHTML数组方式（效率高）</strong></p><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> d1 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">var</span> array = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            array.push(<span class="hljs-string">&#x27;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#x27;</span>);        &#125;        <span class="hljs-built_in">document</span>.body.innerHTML = array.join(<span class="hljs-string">&#x27;&#x27;</span>);        <span class="hljs-keyword">var</span> d2 = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-built_in">console</span>.log(d2 - d1);    &#125;    fn();&lt;/script&gt;</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS DOM操作——事件</title>
    <link href="/2020/08/19/JS%20DOM%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/08/19/JS%20DOM%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h1><h2 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h2><p>JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。</p><p>简单理解： <strong>触发— 响应机制</strong>。</p><p>​    网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。</p><h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul><li>事件源（谁）：触发事件的元素</li><li>事件类型（什么事件）： 例如 click 点击事件</li><li>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</li></ul><p><strong>案例代码</strong></p><pre><code class="hljs js">&lt;body&gt;    &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;唐伯虎&lt;/button&gt;    &lt;script&gt;        <span class="hljs-comment">// 点击一个按钮，弹出对话框</span>        <span class="hljs-comment">// 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素</span>        <span class="hljs-comment">//(1) 事件源 事件被触发的对象   谁  按钮</span>        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>);        <span class="hljs-comment">//(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下</span>        <span class="hljs-comment">//(3) 事件处理程序  通过一个函数赋值的方式 完成</span>        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            alert(<span class="hljs-string">&#x27;点秋香&#x27;</span>);        &#125;    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="执行事件的步骤"><a href="#执行事件的步骤" class="headerlink" title="执行事件的步骤"></a>执行事件的步骤</h2><ol><li>获取事件源</li><li>注册事件（绑定事件）</li><li>添加事件处理程序（采用函数赋值形式）</li></ol><p><strong>案例代码</strong></p><pre><code class="hljs js">&lt;body&gt;    &lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;    &lt;script&gt;        <span class="hljs-comment">// 执行事件步骤</span>        <span class="hljs-comment">// 点击div 控制台输出 我被选中了</span>        <span class="hljs-comment">// 1. 获取事件源</span>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);        <span class="hljs-comment">// 2.绑定事件 注册事件</span>        <span class="hljs-comment">// div.onclick </span>        <span class="hljs-comment">// 3.添加事件处理程序 </span>        div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我被选中了&#x27;</span>);        &#125;    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h2><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击左键触发</td></tr><tr><td>onmouseover</td><td>鼠标经过触发</td></tr><tr><td>onmouseout</td><td>鼠标离开触发</td></tr><tr><td>onfocus</td><td>获得鼠标焦点触发</td></tr><tr><td>onblur</td><td>失去鼠标焦点触发</td></tr><tr><td>onmousemove</td><td>鼠标移动触发</td></tr><tr><td>onmouseup</td><td>鼠标弹起触发</td></tr><tr><td>onmousedown</td><td>鼠标按下触发</td></tr></tbody></table><h2 id="常用的键盘事件"><a href="#常用的键盘事件" class="headerlink" title="常用的键盘事件"></a>常用的键盘事件</h2><table><thead><tr><th>键盘事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onkeyup</td><td>某个键盘按键被松开时触发</td></tr><tr><td>onkeydown</td><td>某个键盘按键被按下时触发</td></tr><tr><td>onkeypress</td><td>某个键盘按键被按下时触发，不识别功能键，如：ctrl、shift、 箭头等</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>如果使用addEventListener 不需要加 on</li><li>onkeypress 和前面2个的区别是：它不识别功能键</li><li>三个事件执行顺序：keydown–&gt;keypress–&gt;keyup</li></ol><pre><code class="hljs javascript">&lt;script&gt;        <span class="hljs-comment">// 常用的键盘事件</span>        <span class="hljs-comment">//1. keyup 按键弹起的时候触发 </span>        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我弹起了&#x27;</span>);        &#125;)        <span class="hljs-comment">//3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊</span>        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我按下了press&#x27;</span>);        &#125;)        <span class="hljs-comment">//2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊</span>        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我按下了down&#x27;</span>);        &#125;)        <span class="hljs-comment">// 4. 三个事件的执行顺序  keydown -- keypress -- keyup</span>&lt;/script&gt;</code></pre><h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><table><thead><tr><th>键盘事件对象属性</th><th>说明</th></tr></thead><tbody><tr><td>keyCode</td><td>返回该键的 ASCII 值</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>onkeydown 和 onkeyup 不区分大小写，onkeypress区分字母大小写</li><li>更多的使用 keydown 和 keyup ，它能识别所有的键（包括功能键）</li><li>keypress不识别功能键，但是 keyCode 属性能区分大小写，返回不同的 ASCII 值</li></ol><p><strong>使用keyCode属性判断用户按下哪个键</strong></p><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-comment">// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值</span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;up:&#x27;</span> + e.keyCode);        <span class="hljs-comment">// 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键</span>        <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">65</span>) &#123;            alert(<span class="hljs-string">&#x27;您按下的a键&#x27;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            alert(<span class="hljs-string">&#x27;您没有按下a键&#x27;</span>)        &#125;    &#125;)    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-comment">// console.log(e);</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;press:&#x27;</span> + e.keyCode);    &#125;)&lt;/script&gt;</code></pre><h1 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h1><h2 id="注册事件（2种方式）"><a href="#注册事件（2种方式）" class="headerlink" title="注册事件（2种方式）"></a>注册事件（2种方式）</h2><p><img src="./1551165252019.png" alt="1551165252019"></p><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><h4 id="addEventListener-事件监听（IE9以后支持）"><a href="#addEventListener-事件监听（IE9以后支持）" class="headerlink" title="addEventListener()事件监听（IE9以后支持）"></a>addEventListener()事件监听（IE9以后支持）</h4><blockquote><p>eventTarget.addEventListener(type, listener[,useCapture])</p><p>type：事件类型字符串，如 click、mouseover，注意不带 on</p><p>listener：事件处理函数，事件发生时，会调用该监听函数</p><p>useCapture：可选参数，是一个布尔值。默认 false。</p></blockquote><p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p><h4 id="attacheEvent-事件监听（IE678支持）"><a href="#attacheEvent-事件监听（IE678支持）" class="headerlink" title="attacheEvent()事件监听（IE678支持）"></a>attacheEvent()事件监听（IE678支持）</h4><blockquote><p>eventTarget.attachEvent(eventNameWithOn,callback)</p><p>eventNameWithOn：事件类型字符串，比如 onclick、onmouseover，这里需要带 on</p><p>callback：事件处理函数，当目标触发事件时回调函数被调用</p></blockquote><p>​    eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p><pre><code class="hljs js">&lt;button&gt;传统注册事件&lt;/button&gt;&lt;button&gt;方法监听注册事件&lt;/button&gt;&lt;button&gt;ie9 attachEvent&lt;/button&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;button&#x27;</span>);    <span class="hljs-comment">// 1. 传统方式注册事件</span>    btns[<span class="hljs-number">0</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-string">&#x27;hi&#x27;</span>);    &#125;    btns[<span class="hljs-number">0</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            alert(<span class="hljs-string">&#x27;hao a u&#x27;</span>);        &#125;   <span class="hljs-comment">// 2. 事件侦听注册事件 addEventListener </span>   <span class="hljs-comment">// (1) 里面的事件类型是字符串 必定加引号 而且不带on</span>   <span class="hljs-comment">// (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）</span>    btns[<span class="hljs-number">1</span>].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-number">22</span>);    &#125;)    btns[<span class="hljs-number">1</span>].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            alert(<span class="hljs-number">33</span>);    &#125;)    <span class="hljs-comment">// 3. attachEvent ie9以前的版本支持</span>    btns[<span class="hljs-number">2</span>].attachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-number">11</span>);    &#125;)&lt;/script&gt;</code></pre><h4 id="事件监听兼容性解决方案"><a href="#事件监听兼容性解决方案" class="headerlink" title="事件监听兼容性解决方案"></a>事件监听兼容性解决方案</h4><p>封装一个函数，函数中判断浏览器的类型：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListener</span>(<span class="hljs-params">element,eventName, fn</span>)</span>&#123;    <span class="hljs-comment">// 判断当前浏览器是否支持 addEventListener 方法</span>    <span class="hljs-keyword">if</span> (element.addEventListener) &#123;        element.addEventListener(eventName, fn);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.attacheEvent) &#123;        element.attacheEvent(<span class="hljs-string">&#x27;on&#x27;</span> + eventName, fn);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 相当于 element.onclick = fn;</span>        element[<span class="hljs-string">&#x27;on&#x27;</span> + eventName] = fn;    &#125; &#125;</code></pre><h2 id="删除事件（解绑事件）"><a href="#删除事件（解绑事件）" class="headerlink" title="删除事件（解绑事件）"></a>删除事件（解绑事件）</h2><blockquote><p>1、传统注册方式</p><p>eventTarget.onclick = null;</p><p>2、方法监听注册方式</p><ol><li>eventTarget.removerEventListener(type,listener[,useCapture]);</li><li>eventTarget.datachEvent(eventNameWithon,callback);</li></ol></blockquote><pre><code class="hljs js">&lt;div&gt;<span class="hljs-number">1</span>&lt;/div&gt;&lt;div&gt;<span class="hljs-number">2</span>&lt;/div&gt;&lt;div&gt;<span class="hljs-number">3</span>&lt;/div&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>);    divs[<span class="hljs-number">0</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-number">11</span>);        <span class="hljs-comment">// 1. 传统方式删除事件</span>        divs[<span class="hljs-number">0</span>].onclick = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 2. removeEventListener 删除事件</span>    divs[<span class="hljs-number">1</span>].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, fn) <span class="hljs-comment">// 里面的fn 不需要调用加小括号</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-number">22</span>);        divs[<span class="hljs-number">1</span>].removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, fn);    &#125;    <span class="hljs-comment">// 3. detachEvent</span>    divs[<span class="hljs-number">2</span>].attachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, fn1);    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-number">33</span>);        divs[<span class="hljs-number">2</span>].detachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, fn1);    &#125;&lt;/script&gt;</code></pre><p><strong>删除事件兼容性解决方案</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventListener</span>(<span class="hljs-params">element,eventName, fn</span>) </span>&#123;    <span class="hljs-comment">// 判断当前浏览器是否支持 removeEventListener 方法</span>    <span class="hljs-keyword">if</span> (element.removeEventListener) &#123;        element.removeEventListener(eventName, fn);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.attacheEvent) &#123;        element.detachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + eventName, fn);    &#125; <span class="hljs-keyword">else</span> &#123;        element[<span class="hljs-string">&#x27;on&#x27;</span> + eventName] = <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><blockquote><p>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。<br>当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。</p><p>那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？</p></blockquote><p>事件流 描述的是从页面中接收事件的顺序。</p><p>事件发生时会在元素节点之间按照特定的顺序传播，这个过程即 DOM 事件流。</p><blockquote><p>比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</p></blockquote><p><img src="./1551166555833.png" alt="1551166555833"></p><p><strong>DOM 事件流会经历3个阶段：</strong> </p><ol><li><p>捕获阶段</p></li><li><p>当前目标阶段</p></li><li><p>冒泡阶段 </p></li></ol><p>​    我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。 </p><p><img src="./1551169007768.png" alt="1551169007768"></p><p><strong>注意：</strong></p><ol><li>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</li><li>onclick 和 attachEvent 只能得到冒泡阶段</li><li>addEventListener(type, listener[,useCapture]) 如果 useCapture 是 true，表示在事件捕获阶段调用事件处理程序；如果是 flase（默认），表示在事件冒泡阶段调用事件处理程序。</li><li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</li></ol><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a><strong>事件冒泡</strong></h3><pre><code class="hljs js">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;son&quot;</span>&gt;son盒子&lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;      <span class="hljs-comment">// onclick 和 attachEvent（ie） 在冒泡阶段触发</span>      <span class="hljs-comment">// 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 </span>      <span class="hljs-comment">// son -&gt; father -&gt;body -&gt; html -&gt; document</span>      <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.son&#x27;</span>);<span class="hljs-comment">// 给son注册单击事件</span>      son.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          alert(<span class="hljs-string">&#x27;son&#x27;</span>);      &#125;, <span class="hljs-literal">false</span>);<span class="hljs-comment">// 给father注册单击事件</span>      <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.father&#x27;</span>);      father.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          alert(<span class="hljs-string">&#x27;father&#x27;</span>);      &#125;, <span class="hljs-literal">false</span>);<span class="hljs-comment">// 给document注册单击事件，省略第3个参数</span>      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          alert(<span class="hljs-string">&#x27;document&#x27;</span>);      &#125;)  &lt;/script&gt;</code></pre><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a><strong>事件捕获</strong></h3><pre><code class="hljs js">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;son&quot;</span>&gt;son盒子&lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;      <span class="hljs-comment">// 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发</span>      <span class="hljs-comment">// document -&gt; html -&gt; body -&gt; father -&gt; son</span>       <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.son&#x27;</span>);<span class="hljs-comment">// 给son注册单击事件，第3个参数为true</span>       son.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;           alert(<span class="hljs-string">&#x27;son&#x27;</span>);       &#125;, <span class="hljs-literal">true</span>);       <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.father&#x27;</span>);<span class="hljs-comment">// 给father注册单击事件，第3个参数为true</span>       father.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;           alert(<span class="hljs-string">&#x27;father&#x27;</span>);       &#125;, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 给document注册单击事件，第3个参数为true</span>      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          alert(<span class="hljs-string">&#x27;document&#x27;</span>);      &#125;, <span class="hljs-literal">true</span>)  &lt;/script&gt;</code></pre><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><h3 id="什么是事件对象"><a href="#什么是事件对象" class="headerlink" title="什么是事件对象"></a>什么是事件对象</h3><p>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</p><p>比如：  </p><ol><li><p>谁绑定了这个事件。</p></li><li><p>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</p></li><li><p>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</p></li></ol><h3 id="事件对象的使用"><a href="#事件对象的使用" class="headerlink" title="事件对象的使用"></a>事件对象的使用</h3><p>事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</p><p>所以，在事件处理函数中声明1个形参用来接收事件对象。</p><pre><code class="hljs javascript">eventTarget.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;    <span class="hljs-comment">// 这个 event 就是事件对象，还可以写成 e / evt</span>&#125;eventTarget.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;     <span class="hljs-comment">// 这个 event 就是事件对象，还可以写成 e / evt</span>&#125;)eventTarget.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,fn);<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;    <span class="hljs-comment">// 这个 event 就是事件对象，还可以写成 e / evt</span>&#125;</code></pre><h3 id="事件对象的兼容性处理"><a href="#事件对象的兼容性处理" class="headerlink" title="事件对象的兼容性处理"></a>事件对象的兼容性处理</h3><p>事件对象本身的获取存在兼容问题：</p><ol><li><p>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</p></li><li><p>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</p><p>解决：e = e || window.event;</p></li></ol><pre><code class="hljs ruby">只要“<span class="hljs-params">||</span>”前面为<span class="hljs-literal">false</span>, 不管“<span class="hljs-params">||</span>”后面是<span class="hljs-literal">true</span> 还是 <span class="hljs-literal">false</span>，都返回 “<span class="hljs-params">||</span>” 后面的值。只要“<span class="hljs-params">||</span>”前面为<span class="hljs-literal">true</span>, 不管“<span class="hljs-params">||</span>”后面是<span class="hljs-literal">true</span> 还是 <span class="hljs-literal">false</span>，都返回 “<span class="hljs-params">||</span>” 前面的值。</code></pre><pre><code class="hljs js">&lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);    div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;            <span class="hljs-comment">// 事件对象</span>            e = e || <span class="hljs-built_in">window</span>.event;            <span class="hljs-built_in">console</span>.log(e);    &#125;&lt;/script&gt;</code></pre><h3 id="事件对象的属性和方法"><a href="#事件对象的属性和方法" class="headerlink" title="事件对象的属性和方法"></a>事件对象的属性和方法</h3><table><thead><tr><th>事件对象属性方法</th><th>说明</th></tr></thead><tbody><tr><td>e.target</td><td>返回触发事件的对象             标准</td></tr><tr><td>e.srcElement</td><td>返回触发事件的对象             非标准，IE6-8使用</td></tr><tr><td>e.type</td><td>返回事件的类型，比如 click、mouseover 等，不带on</td></tr><tr><td>e.cancelBubble</td><td>组织冒泡        非标准，IE6-8使用</td></tr><tr><td>e.returnValue</td><td>阻止默认事件（默认行为）非标准 IE6-8使用。比如不让链接跳转</td></tr><tr><td>e.preventDefaule()</td><td>阻止默认事件（默认行为）标准。比如不让链接跳转</td></tr><tr><td>e.stopPropagation()</td><td>阻止冒泡   标准</td></tr></tbody></table><h3 id="e-target-和-this-的区别"><a href="#e-target-和-this-的区别" class="headerlink" title="e.target 和 this 的区别"></a>e.target 和 this 的区别</h3><ul><li><p>this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</p></li><li><p>e.target 是事件触发的元素。</p></li></ul><blockquote><pre><code class="hljs kotlin">常情况下terget 和 <span class="hljs-keyword">this</span>是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），    这时候<span class="hljs-keyword">this</span>指向的是父元素，因为它是绑定事件的元素对象，    而target指向的是子元素，因为他是触发事件的那个具体元素对象。</code></pre></blockquote><pre><code class="hljs js">&lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);    div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-comment">// e.target 和 this指向的都是div</span>        <span class="hljs-built_in">console</span>.log(e.target);        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);    &#125;);&lt;/script&gt;</code></pre><p>事件冒泡下的e.target和this</p><pre><code class="hljs js">&lt;ul&gt;    &lt;li&gt;abc&lt;/li&gt;    &lt;li&gt;abc&lt;/li&gt;    &lt;li&gt;abc&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);    ul.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;          <span class="hljs-comment">// 我们给ul 绑定了事件  那么this 就指向ul  </span>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// ul</span>          <span class="hljs-comment">// e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li</span>          <span class="hljs-built_in">console</span>.log(e.target); <span class="hljs-comment">// li</span>    &#125;);&lt;/script&gt;</code></pre><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><blockquote><p>html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</p></blockquote><pre><code class="hljs js">&lt;a href=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>&gt;百度&lt;/a&gt;&lt;script&gt;    <span class="hljs-comment">// 2. 阻止默认行为 让链接不跳转 </span>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;a&#x27;</span>);    a.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;         e.preventDefault(); <span class="hljs-comment">//  dom 标准写法</span>    &#125;);    <span class="hljs-comment">// 3. 传统的注册方式</span>    a.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-comment">// 普通浏览器 e.preventDefault();  方法</span>        e.preventDefault();        <span class="hljs-comment">// 低版本浏览器 ie678  returnValue  属性</span>        e.returnValue = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 我们可以利用return false 也能阻止默认行为 没有兼容性问题</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&lt;/script&gt;</code></pre><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p><blockquote><p>标准写法：利用事件对象里面的 stopPropagation() 方法</p><p>e.stopPropagation();</p><p>非标准写法：IE 6-8 利用事件对象 cancelBubble 属性</p><p>e.cancelBubble = true;</p></blockquote><pre><code class="hljs js">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;son&quot;</span>&gt;son儿子&lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;      <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.son&#x27;</span>);<span class="hljs-comment">// 给son注册单击事件</span>      son.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;          alert(<span class="hljs-string">&#x27;son&#x27;</span>);          e.stopPropagation(); <span class="hljs-comment">// stop 停止  Propagation 传播</span>          <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 非标准 cancel 取消 bubble 泡泡</span>      &#125;, <span class="hljs-literal">false</span>);      <span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.father&#x27;</span>);<span class="hljs-comment">// 给father注册单击事件</span>      father.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          alert(<span class="hljs-string">&#x27;father&#x27;</span>);      &#125;, <span class="hljs-literal">false</span>);<span class="hljs-comment">// 给document注册单击事件</span>      <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          alert(<span class="hljs-string">&#x27;document&#x27;</span>);      &#125;)  &lt;/script&gt;</code></pre><p><strong>阻止事件冒泡的兼容性处理</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;    e.stopPropagation();&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;&#125;</code></pre><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p><h4 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h4><pre><code class="hljs plain">把事情委托给别人，代为处理。</code></pre><p>事件委托也称为事件代理，在 jQuery 里面称为事件委派。</p><blockquote><p>说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</p></blockquote><p><strong>js事件中的代理：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是弹窗在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是弹窗在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是弹窗在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是弹窗在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>知否知否，应是弹窗在手<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></code></pre><p>每点击 li 都会弹出对话框，给每个 li 注册事件是非常辛苦的，而且访问 DOM 的次数越多，这就会延长整个页面的交互就绪时间。</p><h4 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h4><p>​    给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</p><h4 id="事件委托的作用"><a href="#事件委托的作用" class="headerlink" title="事件委托的作用"></a>事件委托的作用</h4><ul><li><p>我们只操作了一次 DOM ，提高了程序的性能。</p></li><li><p>动态新创建的子元素，也拥有事件。</p></li></ul><pre><code class="hljs js">&lt;ul&gt;    &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;    <span class="hljs-comment">// 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点</span>    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);    ul.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-comment">// e.target 这个可以得到我们点击的对象</span>        e.target.style.backgroundColor = <span class="hljs-string">&#x27;pink&#x27;</span>;    &#125;)&lt;/script&gt;</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的引用-script</title>
    <link href="/2020/08/17/JS%E7%9A%84%E5%BC%95%E7%94%A8%E2%80%94script/"/>
    <url>/2020/08/17/JS%E7%9A%84%E5%BC%95%E7%94%A8%E2%80%94script/</url>
    
    <content type="html"><![CDATA[<h1 id="JS的三种引用方式："><a href="#JS的三种引用方式：" class="headerlink" title="JS的三种引用方式："></a>JS的三种引用方式：</h1><ul><li>内部引用</li><li>内联引用</li><li>外部引用</li></ul><h2 id="内部引用"><a href="#内部引用" class="headerlink" title="内部引用"></a>内部引用</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">     <span class="hljs-comment">// 在此编写 JavaScript 代码</span></span>   <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="内联引用"><a href="#内联引用" class="headerlink" title="内联引用"></a>内联引用</h2><pre><code class="hljs js">&lt;button onclick=<span class="hljs-string">&quot;createParagraph()&quot;</span>&gt;点我呀&lt;/button&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createParagraph</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> para = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);  para.textContent = <span class="hljs-string">&#x27;你点击了这个按钮！&#x27;</span>;  <span class="hljs-built_in">document</span>.body.appendChild(para);&#125;</code></pre><h2 id="外部引用"><a href="#外部引用" class="headerlink" title="外部引用"></a>外部引用</h2><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;script.js&quot;</span>&gt;&lt;/script&gt;</code></pre><p>注意：外部引用必须有 src 属性。同时也可以有其他属性：async、defer</p><p><code>async</code>（异步）：浏览器在加载文件时不需要中断后续的文件加载，包括 HTML。如果脚本无需等待页面解析，且无依赖独立运行，那么使用 async。</p><p><code>defer</code>（同步）：浏览器加载时必须按照编写代码的先后顺序加载文件。如果脚本无需等待页面解析，且有依赖于其他脚本，调用时使用 defer ，将关联的脚本按照所需顺序置于 HTML 中。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS语法和数据类型</title>
    <link href="/2020/08/17/JS%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/08/17/JS%E8%AF%AD%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><pre><code class="hljs javascript"><span class="hljs-comment">//单行注释</span><span class="hljs-comment">/*</span><span class="hljs-comment">  多行注释</span><span class="hljs-comment">*/</span></code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h2><p>变量的名字又叫做“<strong>标识符</strong>”，必须以字母、下划线（ <code>_</code>）或者美元符号（ <code>$</code>）开头，并且区分大小写。</p><h2 id="JavaScript三种变量声明方式："><a href="#JavaScript三种变量声明方式：" class="headerlink" title="JavaScript三种变量声明方式："></a>JavaScript三种变量声明方式：</h2><ul><li>var：声明一个变量</li><li>let：声明一个块作用域的局部变量，可赋一个初始值</li><li>const：声明一个块作用域的只读常量</li></ul><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 若没有为变量赋初始值，则值默认为 undefined；</span><span class="hljs-keyword">let</span> a;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><span class="hljs-comment">// 若没有声明变量而直接使用，会抛出 ReferenceError误；</span><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// ReferenceError: b is notdefined</span><span class="hljs-comment">// 当变量值为 undefined时，布尔值环境会当做 false数值环境会当做 NaN；</span><span class="hljs-keyword">var</span> a;<span class="hljs-keyword">if</span> (!a) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a为undefined&#x27;</span>); <span class="hljs-comment">// a为undefined</span>&#125;<span class="hljs-built_in">console</span>.log(a + <span class="hljs-number">1</span>); <span class="hljs-comment">//NaN</span><span class="hljs-comment">// 当变量值为 null时，布尔值环境会当做 false，数值境会当做 0；</span><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span><span class="hljs-keyword">if</span> (!a) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a为null&#x27;</span>); <span class="hljs-comment">// a为null</span>&#125;<span class="hljs-built_in">console</span>.log(a + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span></code></pre><h2 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h2><pre><code class="hljs javascript"><span class="hljs-comment">//变量提升</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;等价于<span class="hljs-keyword">var</span> a = <span class="hljs-literal">undefined</span>a = <span class="hljs-number">1</span><span class="hljs-comment">/*</span><span class="hljs-comment"> 函数提升</span><span class="hljs-comment">*/</span><span class="hljs-comment">//函数声明</span>f(); <span class="hljs-comment">// &#x27;hi leo&#x27;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi leo&#x27;</span>);&#125;;<span class="hljs-comment">// 函数表达式</span>g();   <span class="hljs-comment">// Uncaught TypeError: g is not a function</span><span class="hljs-keyword">var</span> g = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-comment">// 换成 let 声明也一样</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi leo&#x27;</span>);&#125;</code></pre><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p><strong>全局变量（var）</strong>：即声明在函数之外，当前文档所有地方都可以访问；<br><strong>局部变量（let）</strong>：即声明在函数内部，仅在当前函数内可以访问；<br><strong>常量（const）</strong>：在声明时必须赋值，之后相同作用域中<strong>不能赋值也不能重新声明</strong>；</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>JavaScript中一共分为<strong>7</strong>中不同类型：</p><ul><li>六种<strong>基本</strong>数据类型：<ul><li>1.Boolean : 布尔值，<code>true</code>和<code>false</code>;</li><li>2.null : 对大小写敏感（即 <code>null</code>/ <code>Null</code>/ <code>NULL</code>完全不同）;</li><li>3.undefined : 空类型，变量未定义时候的值；</li><li>4.Number : 数值类型，如 <code>100</code>;</li><li>5.String : 字符串类型，如’<code>hi pingan</code>‘;</li><li>6.Symbol（ES6新增） : 表示一种唯一且不可变的数据;</li></ul></li><li>以及Object对象类型</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery选择器</title>
    <link href="/2020/08/17/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2020/08/17/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。</p><h1 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h1><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;选择器&quot;</span>)   <span class="hljs-comment">//  里面选择器直接写 CSS 选择器即可，但是要加引号 </span></code></pre><table><thead><tr><th>名称</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>ID选择器</td><td>$(“#id”)</td><td>获取指定 ID 元素</td></tr><tr><td>全选选择器</td><td>$(“*”)</td><td>匹配所有元素</td></tr><tr><td>类选择器</td><td>$(“.class”)</td><td>获取同一类 class 的元素</td></tr><tr><td>标签选择器</td><td>$(“div”)</td><td>获取同一标签的所有元素</td></tr><tr><td>并集选择器</td><td>$(“div,p,li”)</td><td>选取多个元素</td></tr><tr><td>交集选择器</td><td>$(li.current)</td><td>交集元素</td></tr></tbody></table><h1 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h1><p>层级选择器最常用的两个分别为：后代选择器和子代选择器。</p><table><thead><tr><th>名称</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>子代选择器</td><td>$(“ul&gt;li”)</td><td>使用&gt;号，获取亲儿子层级元素；注意，并不会获得孙子层级元素</td></tr><tr><td>后代选择器</td><td>$(“ul li”)</td><td>使用空格，代表后代选择器，获取所有后代元素，包括子孙等</td></tr></tbody></table><pre><code class="hljs javascript">&lt;body&gt;    &lt;div&gt;我是div&lt;/div&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;我是nav div&lt;/div&gt;    &lt;p&gt;我是p&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;                &lt;li&gt;我是ul 的&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.nav&quot;</span>));            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;ul li&quot;</span>));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h1><p>​    筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</p><table><thead><tr><th>语法</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>:first</td><td>$(“li:first”)</td><td>获取第一个 li 元素</td></tr><tr><td>:last</td><td>$(“li:last”)</td><td>获取最后一个 li 元素</td></tr><tr><td>:eq(index)</td><td>$(“li:eq(2)”)</td><td>获取索引号为2的 li 元素，索引号从 0 开始</td></tr><tr><td>:odd</td><td>$(“li:odd”)</td><td>获取索引号为奇数的 li 元素</td></tr><tr><td>:even</td><td>$(“li:even”)</td><td>获取索引号为偶数的 li 元素</td></tr></tbody></table><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>多个里面筛选几个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            $(<span class="hljs-string">&quot;ul li:first&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);</span><span class="javascript">            $(<span class="hljs-string">&quot;ul li:eq(2)&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>);</span><span class="javascript">            $(<span class="hljs-string">&quot;ol li:odd&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;skyblue&quot;</span>);</span><span class="javascript">            $(<span class="hljs-string">&quot;ol li:even&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;pink&quot;</span>);</span>        &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>另:  jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。</p><table><thead><tr><th>语法</th><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>parent()</td><td>$(“li”).parent()</td><td>查找父级</td></tr><tr><td>children(selector)</td><td>$(“ul”).children(“li”)</td><td>相当于$(“ul&gt;li”),最近一级（亲儿子）</td></tr><tr><td>find(selector)</td><td>$(“ul”).find(“li”)</td><td>相当于$(“ul li”),后代选择器</td></tr><tr><td>siblings(selector)</td><td>$(“.first”).siblings(“li”)</td><td>查找兄弟节点，不包括自己本身</td></tr><tr><td>nextAll([expr])</td><td>$(“.first”).nextAll()</td><td>查找当前元素之后所有同辈元素</td></tr><tr><td>prevtAll([expr])</td><td>$(“.last”).prevtAll()</td><td>查找当前元素之前所有同辈元素</td></tr><tr><td>hasClass(class)</td><td>$(‘div’).hasClass(“protected”)</td><td>检查当前元素是否含有某个特定的类，如果有返回 true</td></tr><tr><td>eq(index)</td><td>$(“li”).eq(2)</td><td>相当于$(“li:eq(2)”)，index从 0 开始</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery初识</title>
    <link href="/2020/08/17/jQuery%E5%88%9D%E8%AF%86/"/>
    <url>/2020/08/17/jQuery%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript库"><a href="#JavaScript库" class="headerlink" title="JavaScript库"></a>JavaScript库</h1><p>JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画<code>animate</code>、<code>hide</code>、<code>show</code>，比如获取元素等。</p><h2 id="jQuery概念"><a href="#jQuery概念" class="headerlink" title="jQuery概念"></a>jQuery概念</h2><ul><li><p>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</p></li><li><p>j 就是 JavaScript；   Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。</p></li><li><p>jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</p></li><li><p>学习jQuery本质： 就是学习调用这些函数（方法）。</p></li><li><p>jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。</p></li></ul><h2 id="JavaScript缺点"><a href="#JavaScript缺点" class="headerlink" title="JavaScript缺点"></a>JavaScript缺点</h2><ol><li>不能添加多个入口函数（window,onload）。如果添加多个就会被覆盖。</li><li>原生JS的API名字太长，难记。</li><li>原生JS有时代码会有些冗余</li><li>原生JS中有些属性或者方法有浏览器兼容问题</li><li>原生JS容错率低，前面代码出了问题，后面代码执行不了。</li></ol><h2 id="jQuery优势"><a href="#jQuery优势" class="headerlink" title="jQuery优势"></a>jQuery优势</h2><ol><li>轻量级。核心文件才几十kb，不会影响页面加载速度。</li><li>跨浏览器兼容，基本兼容了现在主流的浏览器。</li><li>链式编程、隐式迭代。</li><li>对事件、样式、动画支持，大大简化了DOM操作。</li><li>支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。</li><li>免费、开源。</li></ol><h1 id="jQuery的使用"><a href="#jQuery的使用" class="headerlink" title="jQuery的使用"></a>jQuery的使用</h1><ul><li>引入jQuery文件</li><li>写一个入口函数</li><li>编写jQuery代码</li></ul><h2 id="jQuery的入口函数"><a href="#jQuery的入口函数" class="headerlink" title="jQuery的入口函数"></a>jQuery的入口函数</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种: 简单易用。</span>$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;       ...  <span class="hljs-comment">// 此处是页面 DOM 加载完成的入口</span>&#125;) ; <span class="hljs-comment">// 第二种: 繁琐，但是也可以实现</span>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   ...  <span class="hljs-comment">//  此处是页面DOM加载完成的入口</span>&#125;);<span class="hljs-comment">/*</span><span class="hljs-comment">   $是jQuery的别称，在代码中可以使用jQuery代替，但为了方便，通常都直接使用 $</span><span class="hljs-comment">   $是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。</span><span class="hljs-comment">*/</span></code></pre><h1 id="JQuery对象和DOM对象"><a href="#JQuery对象和DOM对象" class="headerlink" title="JQuery对象和DOM对象"></a>JQuery对象和DOM对象</h1><ul><li>使用原原生JS获取的对象就是DOM对象</li><li>JQuery方法获取的元素就是JQuery对象</li><li>JQuery对象本质就是：利用$对DOM对象包装后产生的对象（伪数组形式存储）</li></ul><blockquote><p>注意：</p><p>只有jQuery对象才能使用jQuery方法，DOM对象只能使用JS方法</p></blockquote><h2 id="jQuery对象和DOM对象转换"><a href="#jQuery对象和DOM对象转换" class="headerlink" title="jQuery对象和DOM对象转换"></a>jQuery对象和DOM对象转换</h2><p>DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 1.DOM对象转换成jQuery对象，方法只有一种</span><span class="hljs-keyword">var</span> box = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box&#x27;</span>);  <span class="hljs-comment">// 获取DOM对象</span><span class="hljs-keyword">var</span> jQueryObject = $(box);  <span class="hljs-comment">// 把DOM对象转换为 jQuery 对象</span><span class="hljs-comment">// 2.jQuery 对象转换为 DOM 对象有两种方法：</span><span class="hljs-comment">//   2.1 jQuery对象[索引值]</span><span class="hljs-keyword">var</span> domObject1 = $(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]<span class="hljs-comment">//   2.2 jQuery对象.get(索引值)</span><span class="hljs-keyword">var</span> domObject2 = $(<span class="hljs-string">&#x27;div&#x27;</span>).get(<span class="hljs-number">0</span>)</code></pre><blockquote><p>总结：</p><p>实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。</p></blockquote><h1 id="知识铺垫"><a href="#知识铺垫" class="headerlink" title="知识铺垫"></a>知识铺垫</h1><ul><li>jQuery设置样式</li></ul><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;div&#x27;</span>).css(<span class="hljs-string">&#x27;属性&#x27;</span>, <span class="hljs-string">&#x27;值&#x27;</span>)</code></pre><ul><li>jQuery的排他思想</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。</span>$(<span class="hljs-built_in">this</span>).css(“color”,”red”);$(<span class="hljs-built_in">this</span>).siblings(). css(“color”,””);</code></pre><ul><li>隐式迭代</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。</span><span class="hljs-comment">// 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。</span>$(<span class="hljs-string">&#x27;div&#x27;</span>).hide();  <span class="hljs-comment">// 页面中所有的div全部隐藏，不用循环操作</span></code></pre><ul><li>链式编程</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 链式编程是为了节省代码量，看起来更优雅。</span>$(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>).sibling().css(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Node</title>
    <link href="/2020/08/17/%E5%88%9D%E8%AF%86Node/"/>
    <url>/2020/08/17/%E5%88%9D%E8%AF%86Node/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Node？"><a href="#什么是Node？" class="headerlink" title="什么是Node？"></a>什么是Node？</h1><p>Node 是 JavaScript 的一种<strong>运行环境</strong>。可以使 JS 代码不依赖浏览器也可以执行。他俩的差异如下：</p><p><img src="./01.png" alt="img"></p><p>两个运行环境都包含了 ECMScript 。另一方面 JavaScript 包含了 <code>BOM</code> 和 <code>DOM</code>。</p><ul><li>BOM：浏览器对象模型，也就是 <code>window</code> 对象</li><li>DOM：文档对象模型，也就是 <code>document</code> 对象</li></ul><p>而 Node 则包含了 V8 引擎。V8 是 Chrome 浏览器的 <code>JS</code> 引擎，性能和安全性都很高。Node进一步将 V8 引擎加工成可以在任何操作系统中运行 JS 的平台。</p><h1 id="Node-全局对象"><a href="#Node-全局对象" class="headerlink" title="Node 全局对象"></a>Node 全局对象</h1><p><img src="./02.png" alt="img"></p><p>可以看到 JavaScript 全局对象可以分为四类：</p><ol><li>浏览器专属，例如 <code>window</code>、<code>alert</code> 等等；</li><li>Node 专属，例如 <code>process</code>、<code>Buffer</code>、<code>__dirname</code>、<code>__filename</code> 等等；</li><li>浏览器和 Node 共有，但是<strong>实现方式不同</strong>，例如 <code>console</code>、<code>setTimeout</code>、<code>setInterval</code> 等；</li><li>浏览器和 Node 共有，并且属于 <strong>ECMAScript 语言定义</strong>的一部分，例如 <code>Date</code>、<code>String</code>、<code>Promise</code> 等；</li></ol><h2 id="process"><a href="#process" class="headerlink" title="process"></a><strong>process</strong></h2><p><strong>process</strong> 是管理当前 Node 进程状态的对象，提供了与操作系统的简单接口。有以下几种属性</p><pre><code class="hljs javascript">process.pid <span class="hljs-comment">//进程编号</span>proces.env <span class="hljs-comment">//系统环境变量</span>process.argv <span class="hljs-comment">//命令行执行此脚本时输入的参数</span>process.platform <span class="hljs-comment">//当前操作系统的平台</span></code></pre><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><strong>buffer</strong> 让 JS 能够轻松的处理二进制数据流，结合Node 的流接口（stream）能够实现高效的二进制文件处理。</p><h2 id="filename-和-dirname"><a href="#filename-和-dirname" class="headerlink" title="__filename 和 __dirname"></a>__filename 和 __dirname</h2><p>分别表示当前所运行 Node 脚本文件路径和所在的目录路径</p><h1 id="Node-模块化机制"><a href="#Node-模块化机制" class="headerlink" title="Node 模块化机制"></a>Node 模块化机制</h1><h2 id="JS-的缺点："><a href="#JS-的缺点：" class="headerlink" title="JS 的缺点："></a>JS 的缺点：</h2><ul><li>导入多个 JS 文件直接作用于全局命名空间，很容易产生<strong>命名冲突</strong></li><li>导入的 JS 文件之间不能相互访问，很不方便</li><li>导入的 &lt;script &gt; 无法轻易去除或修改</li></ul><h2 id="Node-模块机制浅析"><a href="#Node-模块机制浅析" class="headerlink" title="Node 模块机制浅析"></a>Node 模块机制浅析</h2><p>Node 引入了三个新的全局对象（还是 Node 专属哦）：1）<code>require</code>；2） <code>exports</code> 和 3）<code>module</code>。</p><h3 id="exports-（导出模块）"><a href="#exports-（导出模块）" class="headerlink" title="exports （导出模块）"></a>exports （导出模块）</h3><pre><code class="hljs javascript"><span class="hljs-comment">// myModule.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> *导出函数 add </span><span class="hljs-comment"> *第一个add：模块名称，用于require引用</span><span class="hljs-comment"> *第二个add：函数名称</span><span class="hljs-comment">*/</span> <span class="hljs-built_in">exports</span>.add = add;</code></pre><h3 id="require-（导入模块）"><a href="#require-（导入模块）" class="headerlink" title="require （导入模块）"></a>require （导入模块）</h3><p>require 用于导入其他 Node 模块，其接受一个字符串代表的模块名称或路径，通常被称为<strong>模块标识符。</strong></p><ul><li>直接写模块名称，通常是核心模块或第三方文件模块，例如 <code>os</code>、<code>express</code> 等</li><li>模块的相对路径（不推荐使用绝对路径），指向项目中其他 Node 模块，例如 <code>./utils</code></li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 导入内置库或第三方模块</span><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<span class="hljs-keyword">const</span> myModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./myModule&#x27;</span>);myModule.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">// 通过相对路径导入其他模块</span><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils&#x27;</span>);</code></pre><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><code>module</code> 对象有以下字段：</p><ul><li><code>id</code>：模块的唯一标识符，如果是被运行的主程序（例如 main.js）则为 <code>.</code>，如果是被导入的模块（例如 myModule.js）则等同于此文件名（即下面的 <code>filename</code> 字段）</li><li><code>path</code> 和 <code>filename</code>：模块所在路径和文件名，没啥好说的</li><li><code>exports</code>：模块所导出的内容，实际上<strong>之前的 <code>exports</code> 对象是指向 <code>module.exports</code> 的引用</strong>。例如对于 myModule.js，刚才我们导出了 <code>add</code> 函数，因此出现在了这个 <code>exports</code> 字段里面；而 main.js 没有导出任何内容，因此 <code>exports</code> 字段为空</li><li><code>parent</code> 和 <code>children</code>：用于记录模块之间的导入关系，例如 main.js 中 <code>require</code> 了 myModule.js，那么 main 就是 myModule 的 <code>parent</code>，myModule 就是 main 的 <code>children</code></li><li><code>loaded</code>：模块是否被加载，从上图中可以看出只有 <code>children</code> 中列出的模块才会被加载</li><li><code>paths</code>：这个就是 Node <strong>搜索文件模块的路径列表</strong>，Node 会从第一个路径到最后一个路径依次搜索指定的 Node 模块，找到了则导入，找不到就会报错</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery属性操作</title>
    <link href="/2020/08/17/jQuery%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/08/17/jQuery%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery常用属性操作"><a href="#jQuery常用属性操作" class="headerlink" title="jQuery常用属性操作"></a>jQuery常用属性操作</h1><p>​    jQuery 常用属性操作有三种：prop() / attr() / data() ;</p><h2 id="元素固有属性值-prop"><a href="#元素固有属性值-prop" class="headerlink" title="元素固有属性值 prop()"></a>元素固有属性值 prop()</h2><p>​    所谓元素固有属性就是元素本身自带的属性，比如 &lt;a&gt; 元素里面的 href ，比如 &lt;input&gt; 元素里面的 type。 </p><p><strong>语法</strong></p><ol><li>获取属性语法：prop(“属性”);</li><li>设置属性语法：prop(“属性”,”属性值”)</li></ol><blockquote><p>​    <strong>注意：</strong>prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</p></blockquote><h2 id="元素自定义属性值-attr"><a href="#元素自定义属性值-attr" class="headerlink" title="元素自定义属性值 attr()"></a>元素自定义属性值 attr()</h2><p>​    用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 </p><p><strong>语法</strong></p><ol><li>获取属性：attr(“属性”)    //类似原生 getAttribute()</li><li>设置属性：attr(“属性”,”属性值”)  // 类似原生 setAttribute()</li></ol><blockquote><p>​    <strong>注意：</strong>attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性）</p></blockquote><h2 id="数据缓存-data"><a href="#数据缓存-data" class="headerlink" title="数据缓存 data()"></a>数据缓存 data()</h2><p>​    data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 </p><p><strong>语法</strong></p><ol><li>附加数据：data(“name”,”value”)  // 向被选元素附加数据</li><li>获取数据：data(“name”)   // 向被选元素获取数据</li></ol><blockquote><p>​    <strong>注意：</strong>同时，还可以读取 HTML5 自定义属性  data-index ，得到的是数字型。</p></blockquote><p><strong>演示代码</strong></p><pre><code class="hljs javascript">&lt;body&gt;    &lt;a href=<span class="hljs-string">&quot;http://www.itcast.cn&quot;</span> title=<span class="hljs-string">&quot;都挺好&quot;</span>&gt;都挺好&lt;/a&gt;    &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;&quot;</span> id=<span class="hljs-string">&quot;&quot;</span> checked&gt;    &lt;div index=<span class="hljs-string">&quot;1&quot;</span> data-index=<span class="hljs-string">&quot;2&quot;</span>&gt;我是div&lt;/div&gt;    &lt;span&gt;<span class="hljs-number">123</span>&lt;/span&gt;    &lt;script&gt;        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-comment">//1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值</span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;a&quot;</span>).prop(<span class="hljs-string">&quot;href&quot;</span>));            $(<span class="hljs-string">&quot;a&quot;</span>).prop(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;我们都挺好&quot;</span>);            $(<span class="hljs-string">&quot;input&quot;</span>).change(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-built_in">console</span>.log($(<span class="hljs-built_in">this</span>).prop(<span class="hljs-string">&quot;checked&quot;</span>));            &#125;);            <span class="hljs-comment">// console.log($(&quot;div&quot;).prop(&quot;index&quot;));</span>            <span class="hljs-comment">// 2. 元素的自定义属性 我们通过 attr()</span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).attr(<span class="hljs-string">&quot;index&quot;</span>));            $(<span class="hljs-string">&quot;div&quot;</span>).attr(<span class="hljs-string">&quot;index&quot;</span>, <span class="hljs-number">4</span>);            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).attr(<span class="hljs-string">&quot;data-index&quot;</span>));            <span class="hljs-comment">// 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面</span>            $(<span class="hljs-string">&quot;span&quot;</span>).data(<span class="hljs-string">&quot;uname&quot;</span>, <span class="hljs-string">&quot;andy&quot;</span>);            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;span&quot;</span>).data(<span class="hljs-string">&quot;uname&quot;</span>));            <span class="hljs-comment">// 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型</span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).data(<span class="hljs-string">&quot;index&quot;</span>));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="jQuery-文本属性值"><a href="#jQuery-文本属性值" class="headerlink" title="jQuery 文本属性值"></a>jQuery 文本属性值</h1><p>​    jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。</p><h3 id="jQuery内容文本值"><a href="#jQuery内容文本值" class="headerlink" title="jQuery内容文本值"></a>jQuery内容文本值</h3><p>​    常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。</p><p><strong>语法</strong></p><table><thead><tr><th>普通元素内容 html()   相当于原生的 inner HTML</th><th>普通元素文本内容 text()   相当于原生的 inner Text</th><th>表单的值 val()   相当于原生的 value</th></tr></thead><tbody><tr><td>html()    // 获取元素内容</td><td>text()   //获取元素文本内容</td><td>val()  //获取表单的值</td></tr><tr><td>html(”内容“)   // 设置元素内容</td><td>text(“文本内容”)  // 设置元素的文本内容</td><td>val(“内容”)  //设置表单的值</td></tr></tbody></table><blockquote><p>​    <strong>注意：</strong>html() 可识别标签，text() 不识别标签。</p></blockquote><p><strong>演示代码</strong></p><pre><code class="hljs javascript">&lt;body&gt;    &lt;div&gt;        &lt;span&gt;我是内容&lt;/span&gt;    &lt;/div&gt;    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=<span class="hljs-string">&quot;请输入内容&quot;</span>&gt;    &lt;script&gt;        <span class="hljs-comment">// 1. 获取设置元素内容 html()</span>        <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).html());        <span class="hljs-comment">// $(&quot;div&quot;).html(&quot;123&quot;);</span>        <span class="hljs-comment">// 2. 获取设置元素文本内容 text()</span>        <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).text());        $(<span class="hljs-string">&quot;div&quot;</span>).text(<span class="hljs-string">&quot;123&quot;</span>);        <span class="hljs-comment">// 3. 获取设置表单值 val()</span>        <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;input&quot;</span>).val());        $(<span class="hljs-string">&quot;input&quot;</span>).val(<span class="hljs-string">&quot;123&quot;</span>);    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="jQuery-元素操作"><a href="#jQuery-元素操作" class="headerlink" title="jQuery 元素操作"></a>jQuery 元素操作</h1><p>​    jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。</p><h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><p>​    jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。</p><p><strong>语法1</strong></p><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;div&quot;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index,domEle</span>) </span>&#123;XXX;&#125;);<span class="hljs-comment">/**</span><span class="hljs-comment">  * each() 方法遍历匹配的每一个元素。主要用DOM处理。each 每一个</span><span class="hljs-comment">  * 里面的回调函数有 2 个参数，</span><span class="hljs-comment">  *     index：每个元素的索引号</span><span class="hljs-comment">  *     demEle：是每个DOM元素对象，不是jQuery对象</span><span class="hljs-comment">  * 要使用jQuery方法，需要给这个dom元素转换为jQuery对象 $(domEle)</span><span class="hljs-comment">  */</span></code></pre><blockquote><p>​    注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</p></blockquote><p><strong>语法2</strong></p><pre><code class="hljs javascript">$.each(object, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index,element</span>) </span>&#123;xxx;&#125;)<span class="hljs-comment">/*</span><span class="hljs-comment"> * $.each() 方法可用于遍历任何对象。主要用于数据处理，比如数组，对象</span><span class="hljs-comment"> * 里面的函数有 2 个参数</span><span class="hljs-comment"> *     index：每个元素的索引号;</span><span class="hljs-comment"> *     element：遍历内容</span><span class="hljs-comment"> */</span></code></pre><blockquote><p>​    注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</p></blockquote><p><strong>演示代码</strong></p><pre><code class="hljs javascript">&lt;body&gt;    &lt;div&gt;<span class="hljs-number">1</span>&lt;/div&gt;    &lt;div&gt;<span class="hljs-number">2</span>&lt;/div&gt;    &lt;div&gt;<span class="hljs-number">3</span>&lt;/div&gt;    &lt;script&gt;        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-comment">// 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）</span>            <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];            <span class="hljs-comment">// 1. each() 方法遍历元素 </span>            $(<span class="hljs-string">&quot;div&quot;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, domEle</span>) </span>&#123;                <span class="hljs-comment">// 回调函数第一个参数一定是索引号  可以自己指定索引号号名称</span>                <span class="hljs-comment">// console.log(i);</span>                <span class="hljs-comment">// 回调函数第二个参数一定是 dom 元素对象，也是自己命名</span>                <span class="hljs-comment">// console.log(domEle);  // 使用jQuery方法需要转换 $(domEle)</span>                $(domEle).css(<span class="hljs-string">&quot;color&quot;</span>, arr[i]);                sum += <span class="hljs-built_in">parseInt</span>($(domEle).text());            &#125;)            <span class="hljs-built_in">console</span>.log(sum);            <span class="hljs-comment">// 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据</span>            <span class="hljs-comment">// $.each($(&quot;div&quot;), function(i, ele) &#123;</span>            <span class="hljs-comment">//     console.log(i);</span>            <span class="hljs-comment">//     console.log(ele);</span>            <span class="hljs-comment">// &#125;);</span>            <span class="hljs-comment">// $.each(arr, function(i, ele) &#123;</span>            <span class="hljs-comment">//     console.log(i);</span>            <span class="hljs-comment">//     console.log(ele);</span>            <span class="hljs-comment">// &#125;)</span>            $.each(&#123;                name: <span class="hljs-string">&quot;andy&quot;</span>,                age: <span class="hljs-number">18</span>            &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, ele</span>) </span>&#123;                <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 输出的是 name age 属性名</span>                <span class="hljs-built_in">console</span>.log(ele); <span class="hljs-comment">// 输出的是 andy  18 属性值</span>            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="创建、添加、删除"><a href="#创建、添加、删除" class="headerlink" title="创建、添加、删除"></a>创建、添加、删除</h2><p>​    jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下：</p><p><strong>语法总和</strong></p><pre><code class="hljs javascript"><span class="hljs-comment">// 创建</span>$(<span class="hljs-string">&quot;&lt;li&gt;&lt;/li&gt;&quot;</span>)<span class="hljs-comment">// 内部添加 父子关系</span>element.append(<span class="hljs-string">&quot;内容&quot;</span>)   <span class="hljs-comment">// 把内容放入匹配元素内部最后面</span>element.prepend(<span class="hljs-string">&quot;内容&quot;</span>)   <span class="hljs-comment">// 把内容放入匹配元素内部最前面</span><span class="hljs-comment">// 外部添加 兄弟关系</span>element.after(<span class="hljs-string">&quot;内容&quot;</span>)   <span class="hljs-comment">// 把内容放入目标元素后面</span>element.before(<span class="hljs-string">&quot;内容&quot;</span>)   <span class="hljs-comment">// 把内容放入目标元素前面</span><span class="hljs-comment">// 删除元素</span>element.remove()  <span class="hljs-comment">// 删除匹配的元素（本身）</span>element.empty()   <span class="hljs-comment">// 删除匹配元素集合中所有的子节点</span>element.html(<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment">// 清空匹配的元素内容，有内容可以设置内容</span></code></pre><blockquote><p>​    注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。</p></blockquote><p><strong>案例代码</strong></p><pre><code class="hljs js">&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;原先的li&lt;/li&gt;    &lt;/ul&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;test&quot;</span>&gt;我是原先的div&lt;/div&gt;    &lt;script&gt;        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-comment">// 1. 创建元素</span>            <span class="hljs-keyword">var</span> li = $(<span class="hljs-string">&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;</span>);            <span class="hljs-comment">// 2. 添加元素</span>            <span class="hljs-comment">//     2.1 内部添加</span>            <span class="hljs-comment">// $(&quot;ul&quot;).append(li);  内部添加并且放到内容的最后面 </span>            $(<span class="hljs-string">&quot;ul&quot;</span>).prepend(li); <span class="hljs-comment">// 内部添加并且放到内容的最前面</span>            <span class="hljs-comment">//  2.2 外部添加</span>            <span class="hljs-keyword">var</span> div = $(<span class="hljs-string">&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;</span>);            <span class="hljs-comment">// $(&quot;.test&quot;).after(div);</span>            $(<span class="hljs-string">&quot;.test&quot;</span>).before(div);            <span class="hljs-comment">// 3. 删除元素</span>            <span class="hljs-comment">// $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀</span>            <span class="hljs-comment">// $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子</span>            $(<span class="hljs-string">&quot;ul&quot;</span>).html(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 可以删除匹配的元素里面的子节点 孩子</span>        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="jQuery-尺寸、位置操作"><a href="#jQuery-尺寸、位置操作" class="headerlink" title="jQuery 尺寸、位置操作"></a>jQuery 尺寸、位置操作</h1><p>​    jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</p><h2 id="jQuery-尺寸操作"><a href="#jQuery-尺寸操作" class="headerlink" title="jQuery 尺寸操作"></a>jQuery 尺寸操作</h2><p>​     jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。</p><p><strong>语法</strong></p><table><thead><tr><th>语法</th><th>用法</th></tr></thead><tbody><tr><td>width() / height()</td><td>取得匹配元素宽度和高度值，只算width / height</td></tr><tr><td>innerWidth() / innerHieght</td><td>取得匹配元素宽度和高度值，包含 padding</td></tr><tr><td>outerWidth() / outerHeight()</td><td>取得匹配元素宽度和高度值，包含 padding、border</td></tr><tr><td>outerWidth(true) / outerHeight(true)</td><td>取得匹配元素宽度和高度值，包含 padding、border、margin</td></tr></tbody></table><ul><li>以上参数为空，则是获取相应值、返回的是数字型</li><li>如果参数是数字，则是修改相应值</li><li>参数可以不必写单位</li></ul><p><strong>代码演示</strong></p><pre><code class="hljs javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-comment">// 1. width() / height() 获取设置元素 width和height大小 </span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).width());            <span class="hljs-comment">// $(&quot;div&quot;).width(300);</span>            <span class="hljs-comment">// 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小 </span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).innerWidth());            <span class="hljs-comment">// 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小 </span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).outerWidth());            <span class="hljs-comment">// 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin</span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;div&quot;</span>).outerWidth(<span class="hljs-literal">true</span>));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p>​    注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。</p><h2 id="jQuery-位置操作"><a href="#jQuery-位置操作" class="headerlink" title="jQuery 位置操作"></a>jQuery 位置操作</h2><p>​    jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下: </p><p><strong>语法</strong></p><blockquote><p>offset()：设置 / 获取元素偏移</p><ol><li>offset() 方法设置或返回被选元素对于**<em>文档**</em>的偏移坐标，跟父级没有关系</li><li>2 个属性 left、top<ol><li>offset().top 获取距离文档顶部的距离</li><li>offset().left 获取距离文档左侧的距离</li></ol></li><li>可以设置元素的偏移offset({top:10;left:30});</li></ol><p>position()：获取元素偏移</p><ol><li>position() 方法设置或返回被选元素对于**<em>带有定位的父级**</em>的偏移坐标，如果父级没有定位，则以文档为准</li><li>2 个属性 left、top<ol><li>position().top 获取距离定位父级顶部的距离</li><li>position().left 获取距离定位父级左侧的距离</li></ol></li><li>该方法只能获取</li></ol><p>scrollTop() / scrollLeft()：设置 / 获取元素被卷去的头部和左侧</p><ol><li>scrollTop() 方法设置 / 返回被选元素被卷去的头部</li><li>不跟参数是获取，参数不带单位的数字则是设置被卷去的头部</li></ol></blockquote><p><strong>代码演示</strong></p><pre><code class="hljs javascript">&lt;body&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;father&quot;</span>&gt;        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;son&quot;</span>&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;back&quot;</span>&gt;返回顶部&lt;/div&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;container&quot;</span>&gt;&lt;/div&gt;    &lt;script&gt;        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-comment">// 1. 获取设置距离文档的位置（偏移） offset</span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.son&quot;</span>).offset());            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.son&quot;</span>).offset().top);            <span class="hljs-comment">// $(&quot;.son&quot;).offset(&#123;</span>            <span class="hljs-comment">//     top: 200,</span>            <span class="hljs-comment">//     left: 200</span>            <span class="hljs-comment">// &#125;);</span>            <span class="hljs-comment">// 2. 获取距离带有定位父级位置（偏移） position   如果没有带有定位的父级，则以文档为准</span>            <span class="hljs-comment">// 这个方法只能获取不能设置偏移</span>            <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&quot;.son&quot;</span>).position());            <span class="hljs-comment">// $(&quot;.son&quot;).position(&#123;</span>            <span class="hljs-comment">//     top: 200,</span>            <span class="hljs-comment">//     left: 200</span>            <span class="hljs-comment">// &#125;);</span>              <span class="hljs-comment">// 3. 被卷去的头部</span>              $(<span class="hljs-built_in">document</span>).scrollTop(<span class="hljs-number">100</span>);            <span class="hljs-comment">// 被卷去的头部 scrollTop()  / 被卷去的左侧 scrollLeft()</span>            <span class="hljs-comment">// 页面滚动事件</span>            <span class="hljs-keyword">var</span> boxTop = $(<span class="hljs-string">&quot;.container&quot;</span>).offset().top;            $(<span class="hljs-built_in">window</span>).scroll(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-comment">// console.log(11);</span>                <span class="hljs-built_in">console</span>.log($(<span class="hljs-built_in">document</span>).scrollTop());                <span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">document</span>).scrollTop() &gt;= boxTop) &#123;                    $(<span class="hljs-string">&quot;.back&quot;</span>).fadeIn();                &#125; <span class="hljs-keyword">else</span> &#123;                    $(<span class="hljs-string">&quot;.back&quot;</span>).fadeOut();                &#125;            &#125;);            <span class="hljs-comment">// 返回顶部</span>            $(<span class="hljs-string">&quot;.back&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-comment">// $(document).scrollTop(0);</span>                $(<span class="hljs-string">&quot;body, html&quot;</span>).stop().animate(&#123;                    scrollTop: <span class="hljs-number">0</span>                &#125;);                <span class="hljs-comment">// $(document).stop().animate(&#123;</span>                <span class="hljs-comment">//     scrollTop: 0</span>                <span class="hljs-comment">// &#125;); 不能是文档而是 html和body元素做动画</span>            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote class="pullquote mindmap mindmap-md"><ul><li>jQuery属性操作<ul><li>jQuery常用属性操作<ul><li>prop<ul><li>普通属性+表单属性</li></ul></li><li>attr()<ul><li>普通属性+自定义属性</li></ul></li><li>data()<ul><li>H5新增的data-xxx属性+自定义属性</li></ul></li></ul></li><li>jQuery文本属性<ul><li>html()<ul><li>类似 DOM 的 InnerHTML 属性</li></ul></li><li>text()<ul><li>类似 DOM 的 InnerText 属性</li></ul></li><li>val()<ul><li>类似 DOM 的 value 属性</li></ul></li></ul></li><li>jQuery元素操作<ul><li>遍历<ul><li>each()</li></ul></li><li>创建<ul><li>$(“&lt;div&gt; &lt;/div&gt;”)</li></ul></li><li>添加</li><li>删除<ul><li>remove()：删除指定项</li><li>empty()：情空</li><li>html(“”)：替换</li></ul></li></ul></li><li>jQuery尺寸和位置操作<ul><li>尺寸<ul><li>width()、innerWidth()、outerWidth()、outerWidth(true)。height同理</li></ul></li><li>位置<ul><li>offset()、position()、scrollTop()/scrollLeft() </li></ul></li></ul></li></ul></li></ul></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JavaScript</category>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue指令</title>
    <link href="/2020/08/16/Vue%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/08/16/Vue%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>指令本质就是自定义属性，Vue中的指令都是以 v- 开头。</p><h1 id="内容绑定，事件绑定"><a href="#内容绑定，事件绑定" class="headerlink" title="内容绑定，事件绑定"></a>内容绑定，事件绑定</h1><h2 id="v-text：设置标签内容"><a href="#v-text：设置标签内容" class="headerlink" title="v-text：设置标签内容"></a>v-text：设置标签内容</h2><ul><li><p>默认写法会替换全部内容，使用差值表达式   {{ }}  可以替换指定内容。</p></li><li><p>内部支出写表达式</p></li><li><p>如果数据中有HTML标签会将html标签一并输出</p></li><li><p>注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值</p></li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&#x27;message&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;info&#125;&#125; 上海<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 导入vue 开发环境版本，包含了有帮助的命令行警告 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>            data: &#123;<span class="javascript">                message: <span class="hljs-string">&#x27;Vue 文本指令1&#x27;</span>,</span><span class="javascript">                info:<span class="hljs-string">&#x27;Vue 文本指令2&#x27;</span></span>            &#125;        &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h2 id="v-html：设置标签的innerHTML"><a href="#v-html：设置标签的innerHTML" class="headerlink" title="v-html：设置标签的innerHTML"></a>v-html：设置标签的innerHTML</h2><ul><li><p>用法和v-text 相似 但是他可以将HTML片段填充到标签中</p></li><li><p>可能有安全问题, 一般只在可信任内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上</p></li><li><p>它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&#x27;message&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&#x27;info&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 导入vue 开发环境版本，包含了有帮助的命令行警告 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>          data: &#123;<span class="javascript">                message: <span class="hljs-string">&#x27;Vue 文本指令1&#x27;</span>,</span><span class="handlebars"><span class="xml">                info:&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>&#x27;</span></span>          &#125;      &#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h2 id="v-on基础"><a href="#v-on基础" class="headerlink" title="v-on基础"></a>v-on基础</h2></li><li><p>用来绑定事件的，时间名不需要写on</p></li><li><p>指令可以简写为@。如：v-on:click 缩写为 @click;</p></li><li><p>绑定的方法定义在methods中</p></li><li><p>方法内部通过this关键字可以访问定义在data中的数据</p></li></ul><p><img src="@click.png" alt="img"></p><h1 id="显示切换，属性绑定"><a href="#显示切换，属性绑定" class="headerlink" title="显示切换，属性绑定"></a>显示切换，属性绑定</h1><h2 id="v-show：根据真假切换元素的状态"><a href="#v-show：根据真假切换元素的状态" class="headerlink" title="v-show：根据真假切换元素的状态"></a>v-show：根据真假切换元素的状态</h2><ul><li>原理是修改元素的display，实现显示隐藏</li><li>指令后面的内容最终都会解析为布尔值</li><li>值为true元素显示，值为false元素隐藏</li><li>数据改变后对应的显示状态会同步更新</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换显示状态&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changeIsShow&#x27;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;累加年龄&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;addAge&#x27;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&#x27;isShow&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/apple.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&#x27;age&gt;=18&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/orange.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>            data: &#123;<span class="javascript">                isShow:<span class="hljs-literal">false</span>,</span>                age:17            &#125;,            methods: &#123;<span class="javascript">                changeIsShow:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.isShow = !<span class="hljs-built_in">this</span>.isShow;</span>                &#125;,<span class="javascript">                addAge:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.age++</span>                &#125;            &#125;        &#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h2 id="v-if：根据表达式的真假切换元素的显示状态"><a href="#v-if：根据表达式的真假切换元素的显示状态" class="headerlink" title="v-if：根据表达式的真假切换元素的显示状态"></a>v-if：根据表达式的真假切换元素的显示状态</h2><ul><li>本质通过操作dom元素切换显示状态</li><li>表达式为true，元素存在于dom树中，为flase，从dom树中删除</li><li>频繁切换v-show，反之使用v-if,前者的切换消耗小</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换状态&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;toggIsShow&#x27;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换状态2&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;addAge&#x27;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&#x27;isShow&#x27;</span>&gt;</span>if指令<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&#x27;temperatrue&gt;=30&#x27;</span>&gt;</span>if指令<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>            data: &#123;<span class="javascript">                isShow:<span class="hljs-literal">false</span>,</span>                temperatrue:20            &#125;,            methods: &#123;<span class="javascript">                toggIsShow:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.isShow = !<span class="hljs-built_in">this</span>.isShow;</span>                &#125;,<span class="javascript">                addAge:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.temperatrue++</span>                &#125;            &#125;        &#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h2 id="v-bind：为元素绑定属性"><a href="#v-bind：为元素绑定属性" class="headerlink" title="v-bind：为元素绑定属性"></a>v-bind：为元素绑定属性</h2><ul><li>完整写法是v-bind:属性名</li><li>简写的话可以直接省略v-bind，只保留属性名</li><li>需要动态的增删class建议使用对象的方式</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;isActive ? &#x27;active&#x27; : &#x27;&#x27;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;toggActive&#x27;</span>&gt;</span>            1234        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>            data: &#123;<span class="javascript">                isActive:<span class="hljs-literal">false</span></span>            &#125;,            methods: &#123;<span class="javascript">                toggActive:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.isActive = !<span class="hljs-built_in">this</span>.isActive;</span>                &#125;            &#125;        &#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h1 id="列表循环，表单元素绑定"><a href="#列表循环，表单元素绑定" class="headerlink" title="列表循环，表单元素绑定"></a>列表循环，表单元素绑定</h1><h2 id="v-for：根据数据生成列表结构"><a href="#v-for：根据数据生成列表结构" class="headerlink" title="v-for：根据数据生成列表结构"></a>v-for：根据数据生成列表结构</h2><ul><li>经常数组和v-for一起使用</li><li>语法(item,index) in 数据</li><li>item和index可以结合其他指令一起使用</li><li>数组长度的更新会同步到页面上，是响应式的</li><li><strong>不推荐</strong>同时使用 <code>v-if</code> 和 <code>v-for</code></li><li>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-1&quot;</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 循环结构-遍历数组  </span><span class="hljs-comment">    item 是我们自己定义的一个名字  代表数组里面的每一项  </span><span class="hljs-comment">    items对应的是 data中的数组--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span>    &#123;&#123; item.message &#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">  el: <span class="hljs-string">&#x27;#example-1&#x27;</span>,</span>  data: &#123;    items: [<span class="javascript">      &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;,</span><span class="javascript">      &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;</span>    ]，  &#125;&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="v-on补充"><a href="#v-on补充" class="headerlink" title="v-on补充"></a>v-on补充</h2><ul><li><p>事件绑定的方法写成函数的形式时，可以传入自定义参数</p></li><li><p>定义方法时需要定义形参来接收传入的实参</p></li><li><p>事件的后面跟上 .修饰符 可以对事件进行限制</p></li><li><p>.enter 可以限制触发的按键为回车</p></li><li><p>事件的修饰符有多种</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>          <span class="hljs-comment">&lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&#x27;handle1&#x27;</span>&gt;</span>点击1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>          <span class="hljs-comment">&lt;!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，</span><span class="hljs-comment">                 并且事件对象的名称必须是$event </span><span class="hljs-comment">            --&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&#x27;handle2(123, 456, $event)&#x27;</span>&gt;</span>点击2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>          data: &#123;              num: 0          &#125;,          methods: &#123;<span class="javascript">                handle1: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">console</span>.log(event.target.innerHTML)</span>              &#125;,<span class="javascript">                handle2: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, p1, event</span>) </span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">console</span>.log(p, p1)</span><span class="javascript">                    <span class="hljs-built_in">console</span>.log(event.target.innerHTML)</span><span class="javascript">                    <span class="hljs-built_in">this</span>.num++;</span>              &#125;          &#125;      &#125;);  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>Vue 不推荐我们操作DOM   为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong><br>修饰符是由<strong>点</strong>开头的指令后缀来表示的使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p><p>&lt;!–hexoPostRenderEscape:<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></p></li></ul><p><span class="hljs-comment">&lt;!– 提交事件不再重载页面 –&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></p><p><span class="hljs-comment">&lt;!– 修饰符可以串联   即阻止冒泡也阻止默认事件 –&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop.prevent</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></p><p><span class="hljs-comment">&lt;!– 只当在 event.target 是当前元素自身时触发处理函数 –&gt;</span><br><span class="hljs-comment">&lt;!– 即事件不是从内部元素触发的 –&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>:hexoPostRenderEscape–&gt;</p><h2 id="v-model-便捷的设置和获取表单元素的值"><a href="#v-model-便捷的设置和获取表单元素的值" class="headerlink" title="v-model:便捷的设置和获取表单元素的值"></a>v-model:便捷的设置和获取表单元素的值</h2><ul><li><p>绑定的数据会和表单元素值相关联</p></li><li><p>绑定数据←→表单元素的值</p></li><li><p>限制在 <code>&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;</code>中使用</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;修改message&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;setM&#x27;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&#x27;getM&#x27;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-keyword">var</span> mask = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span>          data:&#123;<span class="javascript">                message:<span class="hljs-string">&#x27;哈哈哈&#x27;</span></span>          &#125;,          methods:&#123;<span class="javascript">                getM:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">                    alert(<span class="hljs-built_in">this</span>.message)</span>              &#125;,<span class="javascript">                setM:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.message = <span class="hljs-string">&#x27;呵呵呵&#x27;</span></span>              &#125;          &#125;      &#125;)  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS选择器</title>
    <link href="/2020/08/16/Css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2020/08/16/Css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="选择器作用"><a href="#选择器作用" class="headerlink" title="选择器作用"></a>选择器作用</h1><p>找到特定HTML元素</p><h1 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h1><ul><li>标签选择器</li></ul><pre><code class="hljs angelscript">标签名&#123;属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; 属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; 属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>; &#125;</code></pre><ul><li>id选择器</li></ul><pre><code class="hljs angelscript">#id名&#123;属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; 属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; 属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>; &#125;</code></pre><ul><li>类选择器</li></ul><pre><code class="hljs angelscript">.类名&#123;属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; 属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; 属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>; &#125;</code></pre><ul><li>通配符选择器</li></ul><pre><code class="hljs angelscript">*&#123;属性<span class="hljs-number">1</span>:属性值<span class="hljs-number">1</span>; 属性<span class="hljs-number">2</span>:属性值<span class="hljs-number">2</span>; 属性<span class="hljs-number">3</span>:属性值<span class="hljs-number">3</span>; &#125;</code></pre><table><thead><tr><th>选择器</th><th>作用</th><th>缺点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签，比如p</td><td>不能差异化选择</td><td>较多</td><td>p { color：red;}</td></tr><tr><td>类选择器</td><td>可以选出1个或者多个标签</td><td>可以根据需求选择</td><td>非常多</td><td>.nav { color: red; }</td></tr><tr><td>id选择器</td><td>一次只能选择器1个标签</td><td>只能使用一次</td><td>不推荐使用</td><td>#nav {color: red;}</td></tr><tr><td>通配符选择器</td><td>选择所有的标签</td><td>选择的太多，有部分不需要</td><td>不推荐使用</td><td>* {color: red;}</td></tr></tbody></table><h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><ul><li>后代选择器</li></ul><pre><code class="hljs css">父级 子级&#123;属性:属性值;属性:属性值;&#125;</code></pre><ul><li>子选择器：必须是儿子辈！！！</li></ul><pre><code class="hljs css">父级&gt;子级&#123;属性:属性值;属性:属性值;&#125;</code></pre><ul><li>交集选择器</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span><span class="hljs-selector-class">.class</span>&#123;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">25px</span>&#125;其中第一个为标签选择器，第二个为<span class="hljs-selector-tag">class</span>选择器，两个选择器之间**不能有空格**，表示为：类名是<span class="hljs-selector-tag">class</span>的<span class="hljs-selector-tag">h3</span>标签</code></pre><ul><li>并集选择器</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-class">.class</span>&#123;<span class="hljs-attribute">color</span>:red;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">25px</span>&#125;通常用于集体声明  ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为 和的意思。</code></pre><ul><li>伪类选择器</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>      <span class="hljs-comment">/* 未访问的链接 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>     <span class="hljs-comment">/* 鼠标移动到链接上 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span>    <span class="hljs-comment">/* 选定的链接 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>   <span class="hljs-comment">/* 已访问的链接 */</span></code></pre><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择元素后代</td><td>是选择所有的子孙后代</td><td>较多</td><td>符号是<strong>空格</strong> .nav a</td></tr><tr><td>子代选择器</td><td>选择 最近一级元素</td><td>只选亲儿子</td><td>较少</td><td>符号是**&gt;** .nav&gt;p</td></tr><tr><td>交集选择器</td><td>选择两个标签交集的部分</td><td>既是 又是</td><td>较少</td><td><strong>没有符号</strong> p.one</td></tr><tr><td>并集选择器</td><td>选择某些相同样式的选择器</td><td>可以用于集体声明</td><td>较多</td><td>符号是<strong>逗号</strong> .nav, .header</td></tr><tr><td>链接伪类选择器</td><td>给链接更改状态</td><td></td><td>较多</td><td>重点记住 a{} 和 a:hover 实际开发的写法</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识CSS</title>
    <link href="/2020/08/16/%E5%88%9D%E5%A7%8BCSS/"/>
    <url>/2020/08/16/%E5%88%9D%E5%A7%8BCSS/</url>
    
    <content type="html"><![CDATA[<ul><li><p>概念：</p><p>CSS(Cascading Style Sheets) ，通常称为CSS样式表或层叠样式表（级联样式表）</p></li><li><p>作用：</p><ul><li>主要用于<strong>设置</strong> HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及<strong>版面的布局和外观显示样式。</strong></li><li>CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。</li></ul></li></ul><h1 id="CSS分类（书写方式）"><a href="#CSS分类（书写方式）" class="headerlink" title="CSS分类（书写方式）"></a>CSS分类（书写方式）</h1><ul><li>行内式： 通过标签的style属性来设置元素的样式</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">标签名</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;</span>&gt;</span> 内容 <span class="hljs-tag">&lt;/<span class="hljs-name">标签名</span>&gt;</span></code></pre><p>缺点：没有实现样式和结构分类，代码冗余。只能控制当前元素</p><ul><li>内嵌式： 将CSS代码集中写在HTML文档的 <code>head</code> 头部标签中，并且用<code>style</code>标签定义</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/CSS&quot;</span>&gt;</span>    选择器（选择的标签） &#123;       属性1: 属性值1;      属性2: 属性值2;       属性3: 属性值3;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><p>缺点：样式和标签没有完全分离，只能控制当前页面</p><ul><li><p>外链式：</p><p>将所有的样式放在一个或多个以 <code>.css</code> 为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css文件路径&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><p>三种样式总结</p><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>权重</th></tr></thead><tbody><tr><td>行内样式</td><td>书写方便</td><td>没有实现样式和结构分离</td><td>少</td><td>高</td></tr><tr><td>内嵌样式</td><td>部分结构和样式分离</td><td>没有完全分离，只能控制当前页面</td><td>较少</td><td>较高</td></tr><tr><td>外链式</td><td>完全实现结构和样式分离</td><td>需要引入</td><td>多</td><td>低</td></tr></tbody></table></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloVue</title>
    <link href="/2020/08/15/HelloVue/"/>
    <url>/2020/08/15/HelloVue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue初识"><a href="#Vue初识" class="headerlink" title="Vue初识"></a>Vue初识</h1><h2 id="Vue是什么？"><a href="#Vue是什么？" class="headerlink" title="Vue是什么？"></a>Vue是什么？</h2><p>Vue是一套<strong>用于构建用户界面的渐进式框架</strong>。 Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p><h2 id="初次使用："><a href="#初次使用：" class="headerlink" title="初次使用："></a>初次使用：</h2><p><img src="day01-1.png" alt="img"></p><h3 id="el：挂载点"><a href="#el：挂载点" class="headerlink" title="el：挂载点"></a>el：挂载点</h3><ul><li>el是用来设置Vue实例挂载（管理）的元素</li><li>Vue会管理el选项命中的元素及其内部的后代元素</li><li>可以使用其他的选择器，但建议使用ID选择器</li><li>可以使用其他的双标签，不能使用html和body</li></ul><h3 id="data：数据对象"><a href="#data：数据对象" class="headerlink" title="data：数据对象"></a>data：数据对象</h3><ul><li>Vue中用到的数据定义在data中</li><li>data中可以写复杂类型（对象、数组等）的数据</li><li>渲染复杂类型的数据时，遵循js的语法即可</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML列表、表格、表单</title>
    <link href="/2020/08/15/HTML%E5%88%97%E8%A1%A8%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E8%A1%A8%E5%8D%95/"/>
    <url>/2020/08/15/HTML%E5%88%97%E8%A1%A8%E3%80%81%E8%A1%A8%E6%A0%BC%E3%80%81%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="列表标签（重点）"><a href="#列表标签（重点）" class="headerlink" title="列表标签（重点）"></a>列表标签（重点）</h1><ul><li><p><strong>概念</strong>：</p><p>容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表</p></li><li><p><strong>特点</strong>：</p><p>列表最大的特点就是  整齐 、整洁、 有序，跟表格类似，但是他可组合自由度会更高。</p></li></ul><h2 id="无序列表-ul-（重点）"><a href="#无序列表-ul-（重点）" class="headerlink" title="无序列表 ul （重点）"></a>无序列表 ul （重点）</h2><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  ......<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p><strong>脚下留心：</strong></p><pre><code class="hljs xml">1. <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>中只能嵌套<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>，直接在<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>标签中输入其他标签或者文字的做法是不被允许的。2. <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>与<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>之间相当于一个容器，可以容纳所有元素。3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！</code></pre><h2 id="有序列表-ol-（了解）"><a href="#有序列表-ol-（了解）" class="headerlink" title="有序列表 ol （了解）"></a>有序列表 ol （了解）</h2><p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  ......<span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre><p>  所有特性基本与ul 一致。  但是实际中比 无序列表 用的少很多。</p><h2 id="自定义列表（理解）"><a href="#自定义列表（理解）" class="headerlink" title="自定义列表（理解）"></a>自定义列表（理解）</h2><p>定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词1解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词2<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词2解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>名词2解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre><h2 id="列表总结"><a href="#列表总结" class="headerlink" title="列表总结"></a>列表总结</h2><table><thead><tr><th>标签名</th><th align="center">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td>&lt;ul&gt;&lt;/ul&gt;</td><td align="center"><strong>无序标签</strong></td><td align="left">里面只能包含li    没有顺序，我们以后布局中最常用的列表</td></tr><tr><td>&lt;ol&gt;&lt;/ol&gt;</td><td align="center">有序标签</td><td align="left">里面只能包含li    有顺序， 使用情况较少</td></tr><tr><td>&lt;dl&gt;&lt;/dl&gt;</td><td align="center">自定义列表</td><td align="left">里面有2个兄弟， dt 和 dd</td></tr></tbody></table><h1 id="表格-table-会使用"><a href="#表格-table-会使用" class="headerlink" title="表格 table(会使用)"></a>表格 table(会使用)</h1><p><strong>表格作用：</strong></p><p>存在即是合理的。  表格的现在还是较为常用的一种标签，但不是用来布局，<strong>常见显示、展示表格式数据。</strong></p><p>因为它可以让数据显示的非常的规整，可读性非常好。</p><p><strong>特别是后台展示数据的时候表格运用是否熟练就显得很重要</strong>，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。</p><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><p>在HTML网页中，要想创建表格，就需要使用表格相关的标签。</p><p><strong>创建表格的基本语法：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格内的文字<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    ...  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre><p>在上面的语法中包含基本的三对HTML标签，分别为 table、tr、td，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释</p><ol><li><p><code>table</code>用于定义一个表格标签。</p></li><li><p><code>tr</code>标签 用于定义表格中的行，必须嵌套在 table标签中。</p></li><li><p><code>td</code> 用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中。</p></li><li><p>字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。</p></li></ol><img src="./07table基本结构.jpg"><p><strong>总结：</strong> </p><ul><li>表格的主要目的是用来显示特殊数据的</li><li>一个完整的表格有表格标签（table），行标签（tr），单元格标签（td）组成，没有列的标签</li></ul><ul><li>&lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 类的单元格</li><li>&lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素</li></ul><h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><p>表格有部分属性我们不常用，这里重点记住 cellspacing 、 cellpadding。</p><img src="./tt.png" /><p>我们经常有个说法，是三参为0，  平时开发的我们这三个参数    border  cellpadding  cellspacing  为  0</p><img src="./07table表格属性.jpg"><h2 id="表头单元格标签th"><a href="#表头单元格标签th" class="headerlink" title="表头单元格标签th"></a>表头单元格标签th</h2><ul><li><p><strong>作用</strong>：</p><ul><li>一般表头单元格位于表格的第一行或第一列，并且文本加粗居中</li></ul></li><li><p><strong>语法</strong>：</p><ul><li>只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 </li></ul><img src="./th.png" /></li></ul><blockquote><p>th 也是一个单元格   只不过和普通的 td单元格不一样，它会让自己里面的文字居中且加粗</p></blockquote><h2 id="表格标题caption"><a href="#表格标题caption" class="headerlink" title="表格标题caption"></a>表格标题caption</h2><p><strong>定义和用法</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>我是表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre><p><strong>注意：</strong> </p><ol><li>caption 元素定义<strong>表格标题</strong>，通常这个标题会被居中且显示于表格之上。</li><li>caption 标签必须紧随 table 标签之后。</li><li>这个标签只存在 表格里面才有意义。</li></ol><h2 id="合并单元格-难点"><a href="#合并单元格-难点" class="headerlink" title="合并单元格(难点)"></a>合并单元格(难点)</h2><h3 id="合并单元格2种方式"><a href="#合并单元格2种方式" class="headerlink" title="合并单元格2种方式"></a>合并单元格2种方式</h3><ul><li><strong>跨行合并</strong>：rowspan=”合并单元格的个数”      </li><li><strong>跨列合并</strong>：colspan=”合并单元格的个数”</li></ul><img src="./08table合并单元格.jpg"><h3 id="合并单元格顺序"><a href="#合并单元格顺序" class="headerlink" title="合并单元格顺序"></a>合并单元格顺序</h3><blockquote><p><strong>合并的顺序我们按照   先上 后下     先左  后右 的顺序</strong> </p></blockquote><h3 id="合并单元格三步曲"><a href="#合并单元格三步曲" class="headerlink" title="合并单元格三步曲"></a>合并单元格三步曲</h3><ol><li>先确定是跨行还是跨列合并</li><li>根据 先上 后下   先左  后右的原则找到目标单元格    然后写上 合并方式 还有 要合并的单元格数量  比如 ： &lt;td colspan=”3”&gt;  &lt;/td&gt;</li><li>删除多余的单元格    </li></ol><h2 id="表格总结"><a href="#表格总结" class="headerlink" title="表格总结"></a>表格总结</h2><table><thead><tr><th>标签名</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td>&lt;table&gt;&lt;/table&gt;</td><td align="left">表格标签</td><td align="left">就是一个四方的盒子</td></tr><tr><td>&lt;tr&gt;&lt;/tr&gt;</td><td align="left">表格行标签</td><td align="left">行标签要再table标签内部才有意义</td></tr><tr><td>&lt;td&gt;&lt;/td&gt;</td><td align="left">单元格标签</td><td align="left">单元格标签是个容器级元素，可以放任何东西</td></tr><tr><td>&lt;th&gt;&lt;/th&gt;</td><td align="left">表头单元格标签</td><td align="left">它还是一个单元格，但是里面的文字会居中且加粗</td></tr><tr><td>&lt;caption&gt;&lt;/caption&gt;</td><td align="left">表格标题标签</td><td align="left">表格的标题，跟着表格一起走，和表格居中对齐</td></tr><tr><td>clospan 和 rowspan</td><td align="left">合并属性</td><td align="left">用来合并单元格的</td></tr></tbody></table><ol><li>表格提供了HTML 中定义表格式数据的方法。</li><li>表格中由行中的单元格组成。</li><li>表格中没有列元素，列的个数取决于行的单元格个数。</li><li>表格不要纠结于外观，那是CSS 的作用。</li><li>表格的学习要求：  能手写表格结构，并且能简单合并单元格。</li></ol><h2 id="表格划分结构（了解）"><a href="#表格划分结构（了解）" class="headerlink" title="表格划分结构（了解）"></a>表格划分结构（了解）</h2><blockquote><p>对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead,tbody,tfoot来标注， 这样更好的分清表格结构</p></blockquote><img src="./thead.png" /><p><strong>注意：</strong></p><ol><li>&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。用来放标题之类的东西。&lt;thead&gt; 内部必须拥有 &lt;tr&gt; 标签！</li><li>&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。放数据本体 。</li><li>&lt;tfoot&gt;&lt;/tfoot&gt;放表格的脚注之类。</li><li>以上标签都是放到table标签中。</li></ol><h1 id="表单标签-掌握"><a href="#表单标签-掌握" class="headerlink" title="表单标签(掌握)"></a>表单标签(掌握)</h1><p><strong>作用：</strong> </p><p>表单目的是为了<strong>收集用户信息</strong>。在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</p><blockquote><p>在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</p></blockquote><img src="./bd.png" /><p>  <strong>表单控件：</strong> </p><p>​       包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p><p>  <strong>提示信息：</strong></p><p>​        一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p><p>  <strong>表单域：</strong>  </p><p>​      他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p><h2 id="input-控件-重点"><a href="#input-控件-重点" class="headerlink" title="input 控件(重点)"></a>input 控件(重点)</h2><ul><li><p>语法：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;属性值&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;你好&quot;</span>&gt;</span></code></pre><ul><li>input 输入的意思 </li><li>&lt;input /&gt;标签为单标签</li><li>type属性设置不同的属性值用来指定不同的控件类型</li><li>除了type属性还有别的属性</li></ul></li><li><p><strong>常用属性</strong>：</p></li></ul><img src="./input.png" /><h3 id="1-type-属性"><a href="#1-type-属性" class="headerlink" title="1. type 属性"></a>1. type 属性</h3><ul><li>这个属性通过改变值，可以决定了你属于那种input表单。</li><li>比如 type = ‘text’  就表示 文本框 可以做 用户名， 昵称等。</li><li>比如 type = ‘password’  就是表示密码框   用户输入的内容 是不可见的。</li></ul><pre><code class="hljs html">用户名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span> 密  码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span></code></pre><h3 id="2-value属性-值"><a href="#2-value属性-值" class="headerlink" title="2. value属性   值"></a>2. value属性   值</h3><pre><code class="hljs html">用户名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span></code></pre><ul><li>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。</li></ul><h3 id="3-name属性"><a href="#3-name属性" class="headerlink" title="3. name属性"></a>3. name属性</h3><pre><code class="hljs html">用户名:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">“username”</span> /&gt;</span></code></pre><p>name表单的名字， 这样，后台可以通过这个name属性找到这个表单。  页面中的表单很多，name主要作用就是用于区别不同的表单。</p><ul><li>name属性后面的值，是我们自己定义的。</li></ul><ul><li>radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以多个选其中的一个啦</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>  /&gt;</span>男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> /&gt;</span>女</code></pre><ul><li>name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。</li></ul><h3 id="4-checked属性"><a href="#4-checked属性" class="headerlink" title="4. checked属性"></a>4. checked属性</h3><ul><li>表示默认选中状态。  较常见于 单选按钮和复选按钮。</li></ul><pre><code class="hljs html">性    别:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span> /&gt;</span>男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span> /&gt;</span>女</code></pre><p>上面这个，表示就默认选中了 男 这个单选按钮</p><h3 id="5-input-属性小结"><a href="#5-input-属性小结" class="headerlink" title="5. input 属性小结"></a>5. input 属性小结</h3><table><thead><tr><th>属性</th><th align="left">说明</th><th>作用</th></tr></thead><tbody><tr><td>type</td><td align="left">表单类型</td><td>用来指定不同的控件类型</td></tr><tr><td>value</td><td align="left">表单值</td><td>表单里面默认显示的文本</td></tr><tr><td>name</td><td align="left">表单名字</td><td>页面中的表单很多，name主要作用就是用于区别不同的表单。</td></tr><tr><td>checked</td><td align="left">默认选中</td><td>表示那个单选或者复选按钮一开始就被选中了</td></tr></tbody></table><h2 id="label标签-理解"><a href="#label标签-理解" class="headerlink" title="label标签(理解)"></a>label标签(理解)</h2><p><strong>目标：</strong></p><p>label标签主要目的是为了提高用户体验。 为用户提高最优秀的服务。</p><p><strong>概念：</strong></p><p>label 标签为 input 元素定义标注（标签）。</p><p><strong>作用：</strong> </p><p> 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</p><p><strong>如何绑定元素呢？</strong></p><ol><li>第一种用法就是用label直接包括input表单。</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span> 用户名： <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></code></pre><p>   适合单个表单选择</p><ol start="2"><li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span></code></pre><blockquote><p> 当我们鼠标点击 label标签里面的文字时， 光标会定位到指定的表单里面</p></blockquote><h2 id="textarea控件-文本域"><a href="#textarea控件-文本域" class="headerlink" title="textarea控件(文本域)"></a>textarea控件(文本域)</h2><img src="./textarea.png" /><ul><li><strong>语法</strong>：</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> &gt;</span>  文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></code></pre><ul><li><p><strong>作用</strong>：</p><p>通过textarea控件可以轻松地创建多行文本输入框.</p><p>cols=”每行中的字符数” rows=”显示的行数”  我们实际开发不用</p></li></ul><h4 id="文本框和文本域区别"><a href="#文本框和文本域区别" class="headerlink" title="文本框和文本域区别"></a>文本框和文本域区别</h4><table><thead><tr><th align="left">表单</th><th align="center">名称</th><th align="center">区别</th><th align="right">默认值显示</th><th align="right">用于场景</th></tr></thead><tbody><tr><td align="left">input type=”text”</td><td align="center">文本框</td><td align="center">只能显示一行文本</td><td align="right">单标签，通过value显示默认值</td><td align="right">用户名、昵称、密码等</td></tr><tr><td align="left">textarea</td><td align="center">文本域</td><td align="center">可以显示多行文本</td><td align="right">双标签，默认值写到标签中间</td><td align="right">留言板</td></tr></tbody></table><h2 id="select下拉列表"><a href="#select下拉列表" class="headerlink" title="select下拉列表"></a>select下拉列表</h2><p><strong>目的：</strong></p><p>如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表。</p><p><strong>语法：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><ul><li>注意：</li></ul><ol><li>&lt;select&gt;  中至少包含一对 option </li><li>在option 中定义selected =” selected “时，当前项即为默认选中项。</li><li>但是我们实际开发会用的比较少</li></ol><h2 id="form表单域"><a href="#form表单域" class="headerlink" title="form表单域"></a>form表单域</h2><ul><li><p>收集的用户信息怎么传递给服务器？</p><p>通过form表单域</p></li><li><p>目的：</p><p>在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。</p></li></ul><p>**语法: **</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;url地址&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;提交方式&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;表单名称&quot;</span>&gt;</span>  各种表单控件<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th align="left">属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td align="left">url地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址。</td></tr><tr><td>method</td><td align="left">get/post</td><td>用于设置表单数据的提交方式，其取值为get或post。</td></tr><tr><td>name</td><td align="left">名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单。</td></tr></tbody></table><h2 id="团队约定"><a href="#团队约定" class="headerlink" title="团队约定"></a>团队约定</h2><h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><ul><li>元素属性值使用双引号语法</li><li>元素属性值可以写上的都写上</li></ul><p><em>推荐：</em></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span> /&gt;</span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><img src="./guifan.png" /><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML常用标签及路径</title>
    <link href="/2020/08/15/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2020/08/15/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h1><p> 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。</p><p> HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 </p><h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><p>排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。</p><h3 id="标题标签h-熟记"><a href="#标题标签h-熟记" class="headerlink" title="标题标签h (熟记)"></a>标题标签h (熟记)</h3><p> 单词缩写：  head   头部标题 </p><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</p><p><strong>标题标签语义：</strong>  作为标题使用，并且依据重要性递减</p><p>其基本语法格式如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>   标题文本   <span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></code></pre><h3 id="段落标签p-熟记"><a href="#段落标签p-熟记" class="headerlink" title="段落标签p ( 熟记)"></a>段落标签p ( 熟记)</h3><p>单词缩写：  paragraph  段落 </p><p><strong>作用语义：</strong></p><p>可以把 HTML 文档分割为若干段落</p><p> 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>  文本内容  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p><h3 id="水平线标签hr-认识"><a href="#水平线标签hr-认识" class="headerlink" title="水平线标签hr(认识)"></a>水平线标签hr(认识)</h3><p>单词缩写：  horizontal  横线 </p><p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，&lt;hr /&gt;就是创建横跨网页水平线的标签。其基本语法格式如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>是单标签</code></pre><p> 在网页中显示默认样式的水平线。</p><h3 id="换行标签br-熟记"><a href="#换行标签br-熟记" class="headerlink" title="换行标签br (熟记)"></a>换行标签br (熟记)</h3><p>单词缩写：  break   打断 ,换行</p><p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></code></pre><p>这时如果还像在word中直接敲回车键换行就不起作用了。</p><h3 id="div-和-span标签-重点"><a href="#div-和-span标签-重点" class="headerlink" title="div 和  span标签(重点)"></a>div 和  span标签(重点)</h3><p>div   span    是没有语义的     是我们网页布局主要的2个盒子</p><p>div 就是  division  的缩写   分割， 分区的意思  其实有很多div 来组合网页。</p><p>span   跨度，跨距；范围    </p><p>语法格式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 这是头部 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>今日价格<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p>他们两个都是盒子，用来装我们网页元素的， 只不过他们有区别，现在我们记住</p><ul><li>div标签  用来布局的，但是现在一行只能放一个div</li><li>span标签  用来布局的，一行上可以放好多个span</li></ul><h3 id="排版标签总结"><a href="#排版标签总结" class="headerlink" title="排版标签总结"></a>排版标签总结</h3><table><thead><tr><th>标签名</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td>&lt;hx&gt;&lt;/hx&gt;</td><td align="left">标题标签</td><td align="left">作为标题使用，并且依据重要性递减</td></tr><tr><td>&lt;p&gt;&lt;/p&gt;</td><td align="left">段落标签</td><td align="left">可以把 HTML 文档分割为若干段落</td></tr><tr><td>&lt;hr /&gt;</td><td align="left">水平线标签</td><td align="left">没啥可说的，就是一条线</td></tr><tr><td>&lt;br /&gt;</td><td align="left">换行标签</td><td align="left"></td></tr><tr><td>&lt;div&gt;&lt;/div&gt;</td><td align="left">div标签</td><td align="left">用来布局的，但是现在一行只能放一个div</td></tr><tr><td>&lt;span&gt;&lt;/span&gt;</td><td align="left">span标签</td><td align="left">用来布局的，一行上可以放好多个span</td></tr></tbody></table><h2 id="文本格式化标签-熟记"><a href="#文本格式化标签-熟记" class="headerlink" title="文本格式化标签(熟记)"></a>文本格式化标签(熟记)</h2><p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p><img src="./tab.png" /><p><strong>区别：</strong></p><p> b  只是加粗        strong  除了可以加粗还有 强调的意思，  语义更强烈。</p><p>剩下的同理…    </p><h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">标签名</span> 属性<span class="hljs-attr">1</span>=<span class="hljs-string">&quot;属性值1&quot;</span> 属性<span class="hljs-attr">2</span>=<span class="hljs-string">&quot;属性值2&quot;</span> …&gt;</span> 内容 <span class="hljs-tag">&lt;/<span class="hljs-name">标签名</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">手机</span> 颜色=<span class="hljs-string">&quot;红色&quot;</span> 大小=<span class="hljs-string">&quot;5寸&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">手机</span>&gt;</span></code></pre><p>提倡：   尽量不使用 样式属性。  </p><h2 id="图像标签img-重点"><a href="#图像标签img-重点" class="headerlink" title="图像标签img (重点)"></a>图像标签img (重点)</h2><p>单词缩写：   image  图像</p><p>要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签&lt;img /&gt;以及和他相关的属性。（它是一个单身狗）</p><p>语法如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像URL&quot;</span> /&gt;</span></code></pre><p>该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。</p><img src="./img.png" /><p><strong>注意:</strong> </p><ol><li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>任何标签的属性都有默认值，省略该属性则取默认值。</li><li>采取  键值对 的格式   key=”value”  的格式  </li></ol><h2 id="链接标签-重点"><a href="#链接标签-重点" class="headerlink" title="链接标签(重点)"></a>链接标签(重点)</h2><p>单词缩写：  anchor 的缩写  基本解释 锚</p><p>在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。</p><p>语法格式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;跳转目标&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本或图像<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>href</td><td align="left">用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td></tr><tr><td>target</td><td align="left">用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li>外部链接 需要添加 http:// <a href="http://www.baidu.com/">www.baidu.com</a></li><li>内部链接 直接链接内部页面名称即可 比如 &lt;a href=”index.html”&gt; 首页 &lt;/a &gt;</li><li>如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。</li><li>不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。</li></ol><h2 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h2><p>在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。</p><p>简单解释：</p><p>注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</p><p>语法格式：</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 注释语句 --&gt;</span>     快捷键是：    ctrl + /       或者 ctrl +shift + /</code></pre><blockquote><p>注释是给人看的，目的是为了更好的解释这部分代码是干啥的， 程序是不执行这个代码的</p></blockquote><h3 id="团队约定"><a href="#团队约定" class="headerlink" title="团队约定"></a>团队约定</h3><p>一般用于简单的描述，如某些状态描述、属性描述等</p><p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行</p><p><em>推荐：</em></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Comment Text --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h1 id="2-路径-重点、难点"><a href="#2-路径-重点、难点" class="headerlink" title="2. 路径(重点、难点)"></a>2. 路径(重点、难点)</h1><p><strong>目录文件夹：</strong> </p><p>就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html文件， 图片 等等。</p> <img src="./g.png" /><p><strong>根目录</strong>   </p><p>打开目录文件夹的第一层  就是 根目录 </p> <img src="./gg.png" /><p>页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： <strong>相对路径</strong>和<strong>绝对路径</strong></p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。</p><table><thead><tr><th>路径分类</th><th align="center">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td>同一级路径</td><td align="center"></td><td align="left">只需输入图像文件的名称即可，如&lt;img src=”baidu.gif” /&gt;。<img src='./04路径同目录.jpg'></td></tr><tr><td>下一级路径</td><td align="center">“/”</td><td align="left">图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images）                         如&lt;img src=”images/baidu.gif” /&gt;。  <img  src='./05路径不同.jpg'/></td></tr><tr><td>上一级路径</td><td align="center">“../”</td><td align="left">在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，                    如&lt;img src=”../baidu.gif” /&gt;。 <img  src='./06路径不同.jpg'/></td></tr></tbody></table><blockquote><p>相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级  简单说，就是 图片 位于 HTML 页面的位置</p></blockquote><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。“D:\web\img\logo.gif”，或完整的网络地址，例如“<a href="http://www.itcast.cn/images/logo.gif%E2%80%9D%E3%80%82">http://www.itcast.cn/images/logo.gif”。</a></p><p><strong>注意：</strong></p><p>绝对路径用的较少，我们理解下就可以了。  但是要注意，它的写法 特别是符号  <code>\</code>  并不是 相对路径的   <code>/</code>    </p><h1 id="5-拓展阅读"><a href="#5-拓展阅读" class="headerlink" title="5. @拓展阅读"></a>5. @拓展阅读</h1><h4 id="5-1-锚点定位-（难点）"><a href="#5-1-锚点定位-（难点）" class="headerlink" title="5.1 锚点定位 （难点）"></a>5.1 锚点定位 （难点）</h4><p>通过创建锚点链接，用户能够快速定位到目标内容。</p><p>创建锚点链接分为两步：</p><pre><code class="hljs html">1. 使用相应的id名标注跳转目标的位置。 (找目标)  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>第2集<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span> 2. 使用<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#id名&quot;</span>&gt;</span>链接文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>创建链接文本（被点击的） （拉关系）  我也有一个姓毕的姥爷..  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#two&quot;</span>&gt;</span></code></pre><h4 id="5-2-base-标签"><a href="#5-2-base-标签" class="headerlink" title="5.2 base 标签"></a>5.2 base 标签</h4><p><strong>语法：</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> /&gt;</span></code></pre><p><strong>总结：</strong> </p><ol><li>base 可以设置整体链接的打开状态   </li><li>base 写到  &lt;head&gt;  &lt;/head&gt;  之间</li><li>把所有的连接 都默认添加 target=”_blank”</li></ol><blockquote><p>全体链接~ 到 ~  全体集合  所有链接 以新窗口打开页面  ~   是 </p></blockquote><h4 id="5-3-预格式化文本pre标签"><a href="#5-3-预格式化文本pre标签" class="headerlink" title="5.3 预格式化文本pre标签"></a>5.3 预格式化文本pre标签</h4><blockquote><p>标签可定义预格式化的文本。被包围在 &lt;pre&gt; 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</p></blockquote><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>  此例演示如何使用 pre 标签  对空行和 空格  进行控制<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></code></pre><blockquote><p>所谓的预格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。 </p></blockquote><h4 id="5-4-特殊字符-（理解）"><a href="#5-4-特殊字符-（理解）" class="headerlink" title="5.4 特殊字符 （理解）"></a>5.4 特殊字符 （理解）</h4><p> 一些特殊的符号，我们再html 里面很难或者 不方便直接 使用， 我们此时可以使用下面的替代代码。</p><img src="./zifu.png" /><p><strong>虽然有很多，但是我们平时用的比较较少， 大家重点记住   空格    大于号 小于号   就可以了，剩下的回来查阅。</strong></p><p><strong>总结：</strong></p><ol><li>是以<strong>运算符</strong><code>&amp;</code>开头,以<strong>分号运算符</strong><code>;</code>结尾。</li><li>他们不是标签，而是符号。</li><li>HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</li></ol><p><strong>团队约定</strong></p><p>   <em>推荐：</em></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>more <span class="hljs-symbol">&amp;gt;</span><span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识HTML</title>
    <link href="/2020/08/15/%E8%AE%A4%E8%AF%86HTML/"/>
    <url>/2020/08/15/%E8%AE%A4%E8%AF%86HTML/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-初识"><a href="#HTML-初识" class="headerlink" title="HTML 初识"></a>HTML 初识</h1><ul><li>HTML 指的是超文本标记语言 (<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage)是用来描述网页的一种语言。</li><li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li><li>标记语言是一套标记标签 (markup tag)</li></ul><blockquote><p>网页是由网页元素组成的 ， 这些元素是利用html标签描述出来，然后通过浏览器解析，就可以显示给用户了。</p></blockquote><p><strong>所谓超文本，有2层含义：</strong> </p><ol><li>因为它可以加入图片、声音、动画、多媒体等内容（**超越文本限制 **）</li><li>不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（**超级链接文本 **）。</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;timg.jpg&quot;</span> /&gt;</span></code></pre><p><strong>html 总结:</strong></p><ul><li>html 是超文本标记(标签)语言</li><li>我们学习html 主要学习html标签</li><li>我们用html标签描述网页元素。 比如 图片标签 、文字标签、链接标签等等</li><li>标签有自己的语法规范，所有的html标签都是用 &lt; &gt; 表示的</li></ul><h2 id="HTML骨架标签"><a href="#HTML骨架标签" class="headerlink" title="HTML骨架标签"></a>HTML骨架标签</h2><p>日常生活中，我们要遵循共同的约定。 </p><p>同理：HTML 有自己的语言语法骨架格式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h4 id="html骨架标签总结"><a href="#html骨架标签总结" class="headerlink" title="html骨架标签总结"></a>html骨架标签总结</h4><table><thead><tr><th align="center">标签名</th><th align="center">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">&lt;html&gt;&lt;/html&gt;</td><td align="center">HTML标签</td><td align="left">页面中最大的标签，我们成为  根标签</td></tr><tr><td align="center">&lt;head&gt;&lt;/head&gt;</td><td align="center">文档的头部</td><td align="left">注意在head标签中我们必须要设置的标签是title</td></tr><tr><td align="center">&lt;titile&gt;&lt;/title&gt;</td><td align="center">文档的标题</td><td align="left">让页面拥有一个属于自己的网页标题</td></tr><tr><td align="center">&lt;body&gt;&lt;/body&gt;</td><td align="center">文档的主体</td><td align="left">元素包含文档的所有内容，页面内容 基本都是放到body里面的</td></tr></tbody></table> <img src='./01html骨架.jpg'><h4 id="团队约定大小写"><a href="#团队约定大小写" class="headerlink" title="团队约定大小写"></a>团队约定大小写</h4><p>HTML标签名、类名、标签属性和大部分属性值统一用<strong>小写</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><h2 id="HTML元素标签分类"><a href="#HTML元素标签分类" class="headerlink" title="HTML元素标签分类"></a>HTML元素标签分类</h2><p><strong>标签：</strong></p><p>在HTML页面中，带有“ &lt;  &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;html&gt;、&lt;head&gt;、&lt;body&gt;都是HTML骨架结构标签。</p><p><strong>分类：</strong></p><ol><li>常规元素（双标签）</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">标签名</span>&gt;</span> 内容 <span class="hljs-tag">&lt;/<span class="hljs-name">标签名</span>&gt;</span>   比如 <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  我是文字  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><ul><li>该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。</li><li>和开始标签相比，结束标签只是在前面加了一个关闭符“/”。</li><li>我们以后接触的基本都是双标签</li></ul><ol start="2"><li>空元素（单标签）</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">标签名</span> /&gt;</span>  比如  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></code></pre><ul><li><p>空元素 用单标签来表示， 简单点说，就是里面不需要包含内容， 只有一个开始标签不需要关闭。</p><blockquote><p>世界上单身狗毕竟是少数的， 大部分还是喜欢成双成对，不要拉下你的另外一半，对待一个双标签要有始有终。</p></blockquote></li></ul><h2 id="HTML标签关系"><a href="#HTML标签关系" class="headerlink" title="HTML标签关系"></a>HTML标签关系</h2><p>主要针对于<strong>双标签</strong> 的相互关系分为两种：</p><ol><li>嵌套关系</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre><p>2.并列关系</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p><strong>倡议：</strong> </p><blockquote><pre><code class="hljs html">如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位（一个tab是4个空格）。如果是并列关系，最好上下对齐。</code></pre></blockquote><blockquote><p>html双标签 可以分为  有 一种是 父子级 包含关系的标签      一种是 兄弟级 并列关系的标签</p></blockquote><h1 id="文档类型-lt-DOCTYPE-gt"><a href="#文档类型-lt-DOCTYPE-gt" class="headerlink" title="文档类型&lt;!DOCTYPE&gt;"></a>文档类型&lt;!DOCTYPE&gt;</h1><p><strong>用法：</strong></p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></code></pre><p><strong>作用：</strong></p><!DOCTYPE><p> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。<!DOCTYPE html>  就是告诉浏览器按照HTML5规范解析页面.</p><p><strong>团队约定：</strong></p><blockquote><pre><code class="hljs apache"><span class="hljs-attribute">HTML</span>文件必须加上 DOCTYPE 声明，并统一使用 HTML<span class="hljs-number">5</span> 的文档声明</code></pre></blockquote><h1 id="页面语言lang"><a href="#页面语言lang" class="headerlink" title="页面语言lang"></a>页面语言lang</h1><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  指定html 语言种类</code></pre><p>最常见的2个：</p><ol><li><code>en</code>定义语言为英语</li><li><code>zh-CN</code>定义语言为中文</li></ol><blockquote> <html lang="zh-CN">  指定该html标签 内容 所用的语言为中文</blockquote><p><strong>团队约定：</strong></p><blockquote><pre><code class="hljs armasm">考虑浏览器和操作系统的兼容性，目前仍然使用 zh-<span class="hljs-meta">CN</span> 属性值</code></pre></blockquote><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></code></pre><pre><code class="hljs pgsql">字符集(<span class="hljs-type">Character</span> <span class="hljs-keyword">set</span>)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</code></pre><p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p><ul><li>gb2312 简单中文  包括6763个汉字  GUO BIAO</li><li>BIG5   繁体中文 港澳台等用</li><li>GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</li><li>UTF-8则基本包含全世界所有国家需要用到的字符</li><li><strong>这句代码非常关键， 是必须要写的代码，否则可能引起乱码的情况。</strong></li></ul><blockquote><p>这句话是让 html 文件是以 UTF-8 编码保存的， 浏览器根据编码去解码对应的html内容。</p></blockquote><p><strong>团队约定：</strong></p><blockquote><pre><code class="hljs 1c">一般情况下统一使用 <span class="hljs-string">&quot;UTF-8&quot;</span> 编码, 请尽量统一写成标准的 <span class="hljs-string">&quot;UTF-8&quot;</span>，不要写成 <span class="hljs-string">&quot;utf-8&quot;</span> 或 <span class="hljs-string">&quot;utf8&quot;</span> 或 <span class="hljs-string">&quot;UTF8&quot;</span>。</code></pre></blockquote><h1 id="HTML标签的语义化"><a href="#HTML标签的语义化" class="headerlink" title="HTML标签的语义化"></a>HTML标签的语义化</h1><p>白话： 所谓标签语义化，就是指标签的含义。</p><p><strong>一句话说出语义化目的:</strong></p><blockquote><p>根据标签的语义，在合适的地方给一个最为合理的标签，让结构更清晰。</p></blockquote><ol><li>方便代码的阅读和维护</li><li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 </li><li>使用语义化标签会具有更好地搜索引擎优化 </li></ol><img src="./02语义化.jpg"><p>语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。(  裸奔起来一样好看 )</p><p>遵循的原则：先确定语义的HTML ，再选合适的CSS。所以，<strong>我们接下来学习html标签，要根据语义去记忆。</strong> HTML网页中任何元素的实现都要依靠HTML标签。</p><h1 id="html5发展之路"><a href="#html5发展之路" class="headerlink" title="html5发展之路"></a>html5发展之路</h1> <img src="./html5.png"/><h4 id="什么是XHTML"><a href="#什么是XHTML" class="headerlink" title="什么是XHTML"></a>什么是XHTML</h4><p>XHTML 是更严格更纯净的 HTML 代码。</p><ul><li>XHTML 指<strong>可扩展超文本标签语言</strong>（EXtensible HyperText Markup Language）。</li><li>XHTML 的目标是取代 HTML。</li><li>XHTML 与 HTML 4.01 几乎是相同的。</li><li>XHTML 是更严格更纯净的 HTML 版本。</li><li>XHTML 是作为一种 XML 应用被重新定义的 HTML。</li><li>XHTML 是一个 W3C 标准。</li></ul><h4 id="HTML和-XHTML之间有什么区别"><a href="#HTML和-XHTML之间有什么区别" class="headerlink" title="HTML和 XHTML之间有什么区别?"></a>HTML和 XHTML之间有什么区别?</h4><ul><li>XHTML 指的是可扩展超文本标记语言</li><li>XHTML 与 HTML 4.01 几乎是相同的</li><li>XHTML 是更严格更纯净的 HTML 版本</li><li>XHTML 是以 XML 应用的方式定义的 HTML</li><li>XHTML 是 2001 年 1 月发布的 W3C 推荐标准</li><li>XHTML 得到所有主流浏览器的支持</li><li>XHTML 元素是以 XML 格式编写的 HTML 元素。XHTML是严格版本的HTML，例如它要求标签必须小写，标签必须被正确关闭，标签顺序必须正确排列，对于属性都必须使用双引号等。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/08/15/hello-world/"/>
    <url>/2020/08/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="cby-git" data-slug-hash="PoNyrBg" data-preview="true" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="PoNyrBg">        <span>See the Pen <a href="https://codepen.io/cby-git/pen/PoNyrBg">        PoNyrBg</a> by cby-git (<a href="https://codepen.io/cby-git">@cby-git</a>)        on <a href="https://codepen.io">CodePen</a>.</span>      </p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="cby-git" data-slug-hash="PoNyrBg" data-preview="true" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="PoNyrBg">        <span>See the Pen <a href="https://codepen.io/cby-git/pen/PoNyrBg">        PoNyrBg</a> by cby-git (<a href="https://codepen.io/cby-git">@cby-git</a>)        on <a href="https://codepen.io">CodePen</a>.</span>      </p>      <script async src="https://static.codepen.io/assets/embed/ei.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
